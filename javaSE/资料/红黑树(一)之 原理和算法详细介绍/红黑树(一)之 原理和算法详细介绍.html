<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.9.2 (454158)"/><meta name="keywords" content="very good"/><meta name="author" content="zhaidj007@hotmail.com"/><meta name="created" content="2017-04-30 23:01:57 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2017-05-05 16:10:02 +0000"/><title>红黑树(一)之 原理和算法详细介绍</title></head><body>
<div>
<div>
<div>
<div><span style="font-size: 18px;"><a href="http://www.cnblogs.com/skywang12345/p/3245399.html#a3">http://www.cnblogs.com/skywang12345/p/3245399.html#a3</a></span></div>
<div><a name="top"/>
<div>
<div>
<div><span style="font-size: 18px;"><a name="Header1_HeaderTitle" href="http://www.cnblogs.com/skywang12345/">skywang12345</a></span></div>
</div>
<div>
<h1><span style="font-size: 18px;">导航</span></h1>
<ul>
<li><span style="font-size: 18px;"><a name="blog_nav_sitehome" href="http://www.cnblogs.com/">博客园</a></span></li>
<li><span style="font-size: 18px;"><a name="blog_nav_myhome" href="http://www.cnblogs.com/skywang12345/">首页</a></span></li>
<li><span style="font-size: 18px;"><a rel="nofollow" href="https://i.cnblogs.com/EditPosts.aspx?opt=1" name="blog_nav_newpost">新随笔</a></span></li>
<li><span style="font-size: 18px;"><a accesskey="9" rel="nofollow" href="https://msg.cnblogs.com/send/%E5%A6%82%E6%9E%9C%E5%A4%A9%E7%A9%BA%E4%B8%8D%E6%AD%BB" name="blog_nav_contact">联系</a></span></li>
<li><span style="font-size: 18px;"><a name="blog_nav_rss" href="http://www.cnblogs.com/skywang12345/rss">订阅</a><a name="blog_nav_rss_image" href="http://www.cnblogs.com/skywang12345/rss"><img src="%E7%BA%A2%E9%BB%91%E6%A0%91(%E4%B8%80)%E4%B9%8B%20%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D.resources/A06950EB-9BA0-4B59-A92E-824D37A474AE.gif" height="10" width="26"/></a></span></li>
<li><span style="font-size: 18px;"><a rel="nofollow" href="https://i.cnblogs.com/" name="blog_nav_admin">管理</a></span></li>
</ul>
<div style="">
<table cellspacing="0" title="日历" cellpadding="0">
<tbody>
<tr>
<td colspan="7">
<table cellspacing="0">
<tbody>
<tr>
<td><span style="font-size: 18px;"><a>&lt;</a></span></td>
<td align="center"><span style="font-size: 18px;">2017年5月</span></td>
<td align="right"><span style="font-size: 18px;"><a>&gt;</a></span></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<th align="center" abbr="日"><span style="font-size: 18px;">日</span></th>
<th align="center" abbr="一"><span style="font-size: 18px;">一</span></th>
<th align="center" abbr="二"><span style="font-size: 18px;">二</span></th>
<th align="center" abbr="三"><span style="font-size: 18px;">三</span></th>
<th align="center" abbr="四"><span style="font-size: 18px;">四</span></th>
<th align="center" abbr="五"><span style="font-size: 18px;">五</span></th>
<th align="center" abbr="六"><span style="font-size: 18px;">六</span></th>
</tr>
<tr>
<td align="center"><span style="font-size: 18px;">30</span></td>
<td align="center"><span style="font-size: 18px;">1</span></td>
<td align="center"><span style="font-size: 18px;">2</span></td>
<td align="center"><span style="font-size: 18px;">3</span></td>
<td align="center"><span style="font-size: 18px;">4</span></td>
<td align="center"><span style="font-size: 18px;">5</span></td>
<td align="center"><span style="font-size: 18px;">6</span></td>
</tr>
<tr>
<td align="center"><span style="font-size: 18px;">7</span></td>
<td align="center"><span style="font-size: 18px;">8</span></td>
<td align="center"><span style="font-size: 18px;">9</span></td>
<td align="center"><span style="font-size: 18px;">10</span></td>
<td align="center"><span style="font-size: 18px;">11</span></td>
<td align="center"><span style="font-size: 18px;">12</span></td>
<td align="center"><span style="font-size: 18px;">13</span></td>
</tr>
<tr>
<td align="center"><span style="font-size: 18px;">14</span></td>
<td align="center"><span style="font-size: 18px;">15</span></td>
<td align="center"><span style="font-size: 18px;">16</span></td>
<td align="center"><span style="font-size: 18px;">17</span></td>
<td align="center"><span style="font-size: 18px;">18</span></td>
<td align="center"><span style="font-size: 18px;">19</span></td>
<td align="center"><span style="font-size: 18px;">20</span></td>
</tr>
<tr>
<td align="center"><span style="font-size: 18px;">21</span></td>
<td align="center"><span style="font-size: 18px;">22</span></td>
<td align="center"><span style="font-size: 18px;">23</span></td>
<td align="center"><span style="font-size: 18px;">24</span></td>
<td align="center"><span style="font-size: 18px;">25</span></td>
<td align="center"><span style="font-size: 18px;">26</span></td>
<td align="center"><span style="font-size: 18px;">27</span></td>
</tr>
<tr>
<td align="center"><span style="font-size: 18px;">28</span></td>
<td align="center"><span style="font-size: 18px;">29</span></td>
<td align="center"><span style="font-size: 18px;">30</span></td>
<td align="center"><span style="font-size: 18px;">31</span></td>
<td align="center"><span style="font-size: 18px;">1</span></td>
<td align="center"><span style="font-size: 18px;">2</span></td>
<td align="center"><span style="font-size: 18px;">3</span></td>
</tr>
<tr>
<td align="center"><span style="font-size: 18px;">4</span></td>
<td align="center"><span style="font-size: 18px;">5</span></td>
<td align="center"><span style="font-size: 18px;">6</span></td>
<td align="center"><span style="font-size: 18px;">7</span></td>
<td align="center"><span style="font-size: 18px;">8</span></td>
<td align="center"><span style="font-size: 18px;">9</span></td>
<td align="center"><span style="font-size: 18px;">10</span></td>
</tr>
</tbody>
</table>
</div>
<div>
<div><span style="font-size: 18px;">统计</span></div>
<ul>
<li><span style="font-size: 18px;">随笔 - 278</span></li>
<li><span style="font-size: 18px;">文章 - 0</span></li>
<li><span style="font-size: 18px;">评论 - 779</span></li>
<li><span style="font-size: 18px;">引用 - 0</span></li>
</ul>
</div>
<div>
<div>
<div>
<h3><span style="font-size: 18px;">搜索</span></h3>
<div>
<div><span style="font-size: 18px;"> </span></div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div>
<div>
<div>
<div>
<h3><span style="font-size: 18px;">常用链接</span></h3>
<ul>
<li><span style="font-size: 18px;"><a title="我的博客的随笔列表" href="http://www.cnblogs.com/skywang12345/p/">我的随笔</a></span></li>
<li><span style="font-size: 18px;"><a title="我发表过的评论列表" href="http://www.cnblogs.com/skywang12345/MyComments.html">我的评论</a></span></li>
<li><span style="font-size: 18px;"><a title="我评论过的随笔列表" href="http://www.cnblogs.com/skywang12345/OtherPosts.html">我的参与</a></span></li>
<li><span style="font-size: 18px;"><a title="我的博客的评论列表" href="http://www.cnblogs.com/skywang12345/RecentComments.html">最新评论</a></span></li>
<li><span style="font-size: 18px;"><a title="我的博客的标签列表" href="http://www.cnblogs.com/skywang12345/tag/">我的标签</a></span></li>
</ul>
</div>
<div>
<h1><span style="font-size: 18px;">随笔分类<span style="font-weight: normal;">(275)</span></span></h1>
<ul>
<li><span style="font-size: 18px;"><a name="CatList_LinkList_0_Link_0" href="http://www.cnblogs.com/skywang12345/category/493848.html">Android(7)</a></span></li>
<li><span style="font-size: 18px;"><a name="CatList_LinkList_0_Link_1" href="http://www.cnblogs.com/skywang12345/category/482610.html">Android NDK编程(9)</a></span></li>
<li><span style="font-size: 18px;"><a name="CatList_LinkList_0_Link_2" href="http://www.cnblogs.com/skywang12345/category/490118.html">Android 系统层(5)</a></span></li>
<li><span style="font-size: 18px;"><a name="CatList_LinkList_0_Link_3" href="http://www.cnblogs.com/skywang12345/category/455318.html">Android 应用层(46)</a></span></li>
<li><span style="font-size: 18px;"><a name="CatList_LinkList_0_Link_4" href="http://www.cnblogs.com/skywang12345/category/476579.html">Computer Culture(2)</a></span></li>
<li><span style="font-size: 18px;"><a name="CatList_LinkList_0_Link_5" href="http://www.cnblogs.com/skywang12345/category/455711.html">Java(111)</a></span></li>
<li><span style="font-size: 18px;"><a name="CatList_LinkList_0_Link_6" href="http://www.cnblogs.com/skywang12345/category/481789.html">Linux/Ubuntu(5)</a></span></li>
<li><span style="font-size: 18px;"><a name="CatList_LinkList_0_Link_7" href="http://www.cnblogs.com/skywang12345/category/548620.html">UML(5)</a></span></li>
<li><span style="font-size: 18px;"><a name="CatList_LinkList_0_Link_8" href="http://www.cnblogs.com/skywang12345/category/540303.html">Windows(1)</a></span></li>
<li><span style="font-size: 18px;"><a name="CatList_LinkList_0_Link_9" href="http://www.cnblogs.com/skywang12345/category/548777.html">设计模式(1)</a></span></li>
<li><span style="font-size: 18px;"><a name="CatList_LinkList_0_Link_10" href="http://www.cnblogs.com/skywang12345/category/508186.html">数据结构_算法(79)</a></span></li>
<li><span style="font-size: 18px;"><a name="CatList_LinkList_0_Link_11" href="http://www.cnblogs.com/skywang12345/category/489072.html">索引(4)</a></span></li>
</ul>
</div>
<div>
<div>
<h3><span style="font-size: 18px;">最新评论</span></h3>
<div>
<div>
<ul>
<li><span style="font-size: 18px;"><a href="http://www.cnblogs.com/skywang12345/p/3344137.html#3679235">1. Re:Java Annotation认知(包括框架图、详细介绍、示例说明)</a></span></li>
<li><span style="font-size: 18px;">文章写得很好，很明白，点赞</span></li>
<li><span style="font-size: 18px;">--mandysss</span></li>
<li><span style="font-size: 18px;"><a href="http://www.cnblogs.com/skywang12345/p/3602369.html#3678658">2. Re:归并排序</a></span></li>
<li><span style="font-size: 18px;">请问楼主，你只怎么想到static int i=0; public static void mergeSortUp2Down(Integer[] arras,int start,int end){ ......</span></li>
<li><span style="font-size: 18px;">--twjitm</span></li>
<li><span style="font-size: 18px;"><a href="http://www.cnblogs.com/skywang12345/p/3659060.html#3675575">3. Re:斐波那契堆(一)之 图文解析 和 C语言的实现</a></span></li>
<li><span style="font-size: 18px;">图文并茂 谢谢</span></li>
<li><span style="font-size: 18px;">--等风</span></li>
<li><span style="font-size: 18px;"><a href="http://www.cnblogs.com/skywang12345/p/3308807.html#3673578">4. Re:Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例</a></span></li>
<li><span style="font-size: 18px;">Mark 一下</span></li>
<li><span style="font-size: 18px;">--Lumia1020</span></li>
<li><span style="font-size: 18px;"><a href="http://www.cnblogs.com/skywang12345/p/3479063.html#3672683">5. Re:Java多线程系列--“基础篇”02之 常用的实现多线程的两种方式</a></span></li>
<li><span style="font-size: 18px;">@都会过去他不是加了一个判断条件嘛，...</span></li>
<li><span style="font-size: 18px;">--爱上角度看</span></li>
</ul>
</div>
</div>
</div>
</div>
<div>
<div>
<h3><span style="font-size: 18px;">阅读排行榜</span></h3>
<div>
<div>
<ul>
<li><span style="font-size: 18px;"><a href="http://www.cnblogs.com/skywang12345/p/3308556.html">1. Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例(44305)</a></span></li>
<li><span style="font-size: 18px;"><a href="http://www.cnblogs.com/skywang12345/p/3245399.html">2. 红黑树(一)之 原理和算法详细介绍(38995)</a></span></li>
<li><span style="font-size: 18px;"><a href="http://www.cnblogs.com/skywang12345/p/3154150.html">3. Android 布局之GridLayout(37899)</a></span></li>
<li><span style="font-size: 18px;"><a href="http://www.cnblogs.com/skywang12345/p/java_threads_category.html">4. Java多线程系列目录(共43篇)(37112)</a></span></li>
<li><span style="font-size: 18px;"><a href="http://www.cnblogs.com/skywang12345/p/3603935.html">5. 数据结构与算法系列 目录(35455)</a></span></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div><span style="font-size: 18px;"> </span></div>
</div>
</div>
</div>
<div>
<div><span style="font-size: 18px;"><a name="cb_post_title_url" href="http://www.cnblogs.com/skywang12345/p/3245399.html">红黑树(一)之 原理和算法详细介绍</a></span></div>
</div>
</div>
<div>
<p><span style="font-size: 18px;"> </span></p>
<h3><span style="font-size: 18px;"><strong><span style="font-family: 黑体; color: rgb(0, 0, 0);">概要</span></strong></span></h3>
<p><span style="font-size: 18px;"><strong>目录</strong><br/>
<a href="http://www.cnblogs.com/skywang12345/p/3245399.html#a1">1 红黑树的介绍</a><br/>
<a href="http://www.cnblogs.com/skywang12345/p/3245399.html#aa2">2 红黑树的应用</a><a href="http://www.cnblogs.com/skywang12345/p/3245399.html#a2"><br/></a><a href="http://www.cnblogs.com/skywang12345/p/3245399.html#a2">3 红黑树的时间复杂度和相关证明</a><br/>
<a href="http://www.cnblogs.com/skywang12345/p/3245399.html#a3">4 红黑树的基本操作(一) 左旋和右旋</a><br/>
<a href="http://www.cnblogs.com/skywang12345/p/3245399.html#aa5">5 红黑树的基本操作(二) 添加</a><br/>
<a href="http://www.cnblogs.com/skywang12345/p/3245399.html#a34">6 红黑树的基本操作(三) 删除</a></span></p>
<p><span style="font-size: 18px;"> </span></p>
<p><span style="font-size: 18px;">     作者：<a href="http://www.cnblogs.com/skywang12345/">Sky Wang</a>    于 2013-08-08                          </span></p>
<p><span style="font-size: 18px;">     概述：R-B Tree，又称为“红黑树”。本文参考了《算法导论》中红黑树相关知识，加之自己的理解，然后以图文的形式对红黑树进行说明。本文的主要内容包括：红黑树的特性，红黑树的时间复杂度和它的证明，红黑树的左旋、右旋、插入、删除等操作。</span></p>
<p><span style="font-size: 18px;">     <span style="color: #ff0000;"><strong>请尊重版权，转载注明出处</strong></span>：<a href="http://www.cnblogs.com/skywang12345/p/3245399.html">http://www.cnblogs.com/skywang12345/p/3245399.html</a></span></p>
<hr/>
<p><span style="font-size: 18px;"><strong>更多内容</strong>: <span style="text-decoration: underline;"><span style="color: #ff0000; text-decoration: underline;"><a href="http://www.cnblogs.com/skywang12345/p/3603935.html"><span style="color: #ff0000; text-decoration: underline;">数据结构与算法系列 目录</span></a> </span></span></span></p>
<p><span style="font-size: 18px;">(01) <a name="cb_post_title_url" href="http://www.cnblogs.com/skywang12345/p/3245399.html">红黑树(一)之 原理和算法详细介绍</a><br/>
(02) <a href="http://www.cnblogs.com/skywang12345/p/3624177.html">红黑树(二)之 C语言的实现</a><br/>
(03) <a href="http://www.cnblogs.com/skywang12345/p/3624202.html">红黑树(三)之 Linux内核中红黑树的经典实现<br/></a>(04) <a href="http://www.cnblogs.com/skywang12345/p/3624291.html">红黑树(四)之 C++的实现 <br/></a>(05) <a href="http://www.cnblogs.com/skywang12345/p/3624343.html">红黑树(五)之 Java的实现</a><a href="http://www.cnblogs.com/skywang12345/p/3624291.html"><br/></a>(06) <a href="http://www.cnblogs.com/skywang12345/p/3644742.html">红黑树(六)之 参考资料</a></span></p>
<p><span style="font-size: 18px;"> </span></p>
<h3><a name="a1"/><span style="font-size: 18px;"><strong><span style="font-family: 黑体; color: rgb(0, 0, 0);">R-B Tree简介</span></strong></span></h3>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">    R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。</span></span></p>
<p><span style="font-size: 18px;"><strong>红黑树的特性</strong>:<br/>
<strong><span style="color: rgb(0, 128, 0);">（1）每个节点或者是黑色，或者是红色。</span></strong><br/>
<strong><span style="color: rgb(0, 128, 0);">（2）根节点是黑色。</span></strong><br/>
<strong><span style="color: rgb(0, 128, 0);">（3）每个叶子节点（NIL）是黑色。 <span style="color: #ff0000;">[注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]</span></span></strong><br/>
<strong><span style="color: rgb(0, 128, 0);">（4）如果一个节点是红色的，则它的子节点必须是黑色的。</span></strong><br/>
<strong><span style="color: rgb(0, 128, 0);">（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</span></strong></span></p>
<p><span style="font-size: 18px;"><strong><span style="color: #ff0000;">注意</span></strong>：<br/>
<span style="color: rgb(255, 0, 0);">(01) 特性(3)中的叶子节点，是只为空(NIL或null)的节点。</span><br/>
<span style="color: rgb(255, 0, 0);">(02) 特性(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。</span></span></p>
<p><span style="font-size: 18px;">红黑树示意图如下：</span></p>
<p><span style="font-size: 18px;"><a href="http://images.cnitblog.com/i/497634/201403/251730074203156.jpg"><img src="%E7%BA%A2%E9%BB%91%E6%A0%91(%E4%B8%80)%E4%B9%8B%20%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D.resources/8D90F154-52DC-40E3-87CF-8C491DE0BD54.jpg" height="452" width="928"/></a></span></p>
<p><span style="font-size: 18px;"> </span></p>
<h3><span style="font-size: 18px;"><strong><span style="font-family: 黑体; color: rgb(0, 0, 0);"><a name="aa2"/>红黑树的应用</span></strong></span></h3>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是O(lgn)，效率非常之高。</span><br/>
<span style="color: rgb(0, 0, 0);">例如，Java集合中的<a href="http://www.cnblogs.com/skywang12345/p/3311268.html"><span style="text-decoration: underline;">TreeSet</span></a>和<a href="http://www.cnblogs.com/skywang12345/p/3310928.html"><span style="text-decoration: underline;">TreeMap</span></a>，C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。</span></span></p>
<p><span style="font-size: 18px;"> </span></p>
<h3><a name="a2"/><span style="font-size: 18px;"><strong><span style="font-family: 黑体; color: rgb(0, 0, 0);">红黑树的时间复杂度和相关证明<br/></span></strong></span></h3>
<p><span style="font-size: 18px;"><strong>红黑树的时间复杂度为: O(lgn)</strong><br/>
<span style="color: rgb(0, 0, 0);">下面通过“<em>数学归纳法</em>”对红黑树的时间复杂度进行证明。</span></span></p>
<p><span style="font-size: 18px;">定理：<span style="color: #ff0000;"><strong>一棵含有n个节点的红黑树的高度至多为2log(n+1)</strong></span>.</span></p>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">证明：</span><br/>
<span style="color: rgb(0, 0, 0);">    "一棵含有n个节点的红黑树的高度至多为2log(n+1)" 的<strong>逆否命题</strong>是 "高度为h的红黑树，它的包含的内节点个数至少为 2<span style="font-size: 18px;"><sup>h/2</sup>-1个"。</span></span><br/>
<span style="color: rgb(0, 0, 0);">    我们只需要证明逆否命题，即可证明原命题为真；即只需证明 <span style="color: #008000;">"高度为h的红黑树，它的包含的内节点个数至少为 2<span style="font-size: 18px;"><sup>h/2</sup>-1个"</span></span>。</span></span></p>
<p><span style="font-size: 18px;"><span style="color: #000000;">    从某个节点x出发（不包括该节点）到达一个叶节点的任意一条路径上，黑色节点的个数称为该节点的黑高度(x's black height)，记为<strong>bh(x)</strong>。关于bh(x)有两点需要说明： <br/>
    第1点：根据红黑树的"<strong>特性(5)</strong> ，即<em>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点</em>"可知，从节点x出发到达的所有的叶节点具有相同数目的黑节点。<strong>这也就意味着，bh(x)的值是唯一的</strong>！<br/>
    第2点：根据红黑色的"特性(4)，即<em>如果一个节点是红色的，则它的子节点必须是黑色的</em>"可知，从节点x出发达到叶节点"所经历的黑节点数目"&gt;= "所经历的红节点的数目"。假设x是根节点，则可以得出结论"<strong>bh(x) &gt;= h/2</strong>"。进而，我们只需证明 "<span style="color: #008000;">高度为h的红黑树，它的包含的黑节点个数至少为 2<span style="font-size: 18px;"><sup>bh(x)</sup>-1个</span></span>"即可。</span></span></p>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">    到这里，我们将需要证明的定理已经由</span><br/>
<span style="color: rgb(0, 0, 0);"><strong>"<span style="color: #ff0000;">一棵含有n个节点的红黑树的高度至多为2log(n+1)</span>"</strong></span><br/>
<span style="color: rgb(0, 0, 0);">    转变成只需要证明</span><br/>
<span style="color: #000000;"><strong>"<span style="color: #ff0000;">高度为h的红黑树，它的包含的内节点个数至少为 2<span style="font-size: 18px;"><sup>bh(x)</sup>-1个</span></span>"。</strong></span></span></p>
<p><span style="font-size: 18px;"><br/>
<span style="color: rgb(0, 0, 0);">下面通过"数学归纳法"开始论证高度为h的红黑树，它的包含的内节点个数至少为 2<span style="font-size: 18px;"><sup>bh(x)</sup>-1个"。</span></span></span></p>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">(01) 当树的高度h=0时，</span><br/>
<span style="color: rgb(0, 0, 0);">    内节点个数是0，bh(x) 为0，2<span style="font-size: 18px;"><sup>bh(x)</sup>-1 也为 0。显然，原命题成立。</span></span></span></p>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">(02) 当h&gt;0，且树的高度为 h-1 时，它包含的节点个数至少为 2<span style="font-size: 18px;"><sup>bh(x)-1</sup>-1。这个是根据(01)推断出来的！</span></span></span></p>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">    下面，由树的高度为 h-1 的已知条件推出“树的高度为 h 时，它所包含的节点树为 2<span style="font-size: 18px;"><sup>bh(x)</sup>-1”。</span></span></span></p>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">    当树的高度为 h 时，</span><br/>
<span style="color: rgb(0, 0, 0);">    对于节点x(x为根节点)，其黑高度为bh(x)。</span><br/>
<span style="color: rgb(0, 0, 0);">    对于节点x的左右子树，它们黑高度为 bh(x) 或者 bh(x)-1。</span><br/>
<span style="color: rgb(0, 0, 0);">    根据(02)的已知条件，我们已知 "x的左右子树，即高度为 h-1 的节点，它包含的节点至少为 2<span style="font-size: 18px;"><sup>bh(x)-1</sup>-1 个"；</span></span></span></p>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">    所以，节点x所包含的节点至少为 ( 2<span style="font-size: 18px;"><sup>bh(x)-1</sup>-1 ) + ( 2<sup><span style="font-size: 18px;">bh(x)-1</span></sup>-1 ) + 1 = 2^<sup><span style="font-size: 18px;">bh(x)</span></sup>-1。即节点x所包含的节点至少为 2<sup><span style="font-size: 18px;">bh(x)</span></sup>-1。</span></span><br/>
<span style="color: rgb(0, 0, 0);">    因此，原命题成立。</span></span></p>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">    由(01)、(02)得出，"高度为h的红黑树，它的包含的内节点个数至少为 2^<span style="font-size: 18px;"><sup>bh(x)</sup>-1个"。</span></span><br/>
<span style="color: rgb(0, 0, 0);">    因此，“一棵含有n个节点的红黑树的高度至多为2log(n+1)”。</span></span></p>
<p><span style="font-size: 18px;"> </span></p>
<h3><a name="a3"/><span style="font-size: 18px;"><strong><span style="font-family: 黑体; color: rgb(0, 0, 0);">红黑树的基本操作(一) 左旋和右旋</span></strong></span></h3>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">红黑树的基本操作是<strong>添加</strong>、<strong>删除</strong>。 在对红黑树进行添加或删除之后，都会用到旋转方法。为什么呢？道理很简单，添加或删除红黑树中的节点之后，红黑树就发生了变化，可能不满足红黑树的5条性 质，也就不再是一颗红黑树了，而是一颗普通的树。而通过旋转，可以使这颗树重新成为红黑树。简单点说，旋转的目的是让树保持红黑树的特性。</span><br/>
<span style="color: rgb(0, 0, 0);">旋转包括两种：<strong>左旋</strong> 和 <strong>右旋</strong>。下面分别对它们进行介绍。</span></span></p>
<p><span style="font-size: 18px;"><span style="color: #000000;"> </span></span></p>
<p><span style="font-size: 18px;"><span style="color: #000000;"><a name="a31"/><strong>1. 左旋</strong></span></span></p>
<p><span style="font-size: 18px;"><a href="http://images.cnitblog.com/i/497634/201403/251733282013849.jpg"><img src="%E7%BA%A2%E9%BB%91%E6%A0%91(%E4%B8%80)%E4%B9%8B%20%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D.resources/0D588E25-8BAA-4F1A-9866-5D77A37E424B.jpg" height="301" width="550"/></a></span></p>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">对x进行左旋，意味着"将x变成一个左节点"。</span></span></p>
<p><span style="font-size: 18px;"><br/>
<span style="color: rgb(0, 0, 0);">左旋的伪代码《算法导论》：参考上面的示意图和下面的伪代码，理解“红黑树T的节点x进行左旋”是如何进行的。</span></span></p>
<div>
<div><span style="font-size: 18px;"><a title="复制代码"><img src="%E7%BA%A2%E9%BB%91%E6%A0%91(%E4%B8%80)%E4%B9%8B%20%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D.resources/B1A611E1-C126-4568-9758-1FBBC7E73D21.gif" height="20" width="20"/></a></span></div>
<pre>
<span style="font-size: 18px;">
LEFT-<span style="color: #000000;">ROTATE(T, x)  
</span><span style="color: #800080;">01</span>  y ← right[x]            <span style="color: #008000;">//</span><span style="color: #008000;"> 前提：这里假设x的右孩子为y。下面开始正式操作</span>
<span style="color: #800080;">02</span>  right[x] ← left[y]      <span style="color: #008000;">//</span><span style="color: #008000;"> 将 “y的左孩子” 设为 “x的右孩子”，即 将β设为x的右孩子</span>
<span style="color: #800080;">03</span>  p[left[y]] ← x          <span style="color: #008000;">//</span><span style="color: #008000;"> 将 “x” 设为 “y的左孩子的父亲”，即 将β的父亲设为x</span>
<span style="color: #800080;">04</span>  p[y] ← p[x]             <span style="color: #008000;">//</span><span style="color: #008000;"> 将 “x的父亲” 设为 “y的父亲”</span>
<span style="color: #800080;">05</span>  <span style="color: #0000ff;">if</span> p[x] =<span style="color: #000000;"> nil[T]       
</span><span style="color: #800080;">06</span>  then root[T] ← y                 <span style="color: #008000;">//</span><span style="color: #008000;"> 情况1：如果 “x的父亲” 是空节点，则将y设为根节点</span>
<span style="color: #800080;">07</span>  <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> x =<span style="color: #000000;"> left[p[x]]  
</span><span style="color: #800080;">08</span>            then left[p[x]] ← y    <span style="color: #008000;">//</span><span style="color: #008000;"> 情况2：如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”</span>
<span style="color: #800080;">09</span>            <span style="color: #0000ff;">else</span> right[p[x]] ← y   <span style="color: #008000;">//</span><span style="color: #008000;"> 情况3：(x是它父节点的右孩子) 将y设为“x的父节点的右孩子”</span>
<span style="color: #800080;">10</span>  left[y] ← x             <span style="color: #008000;">//</span><span style="color: #008000;"> 将 “x” 设为 “y的左孩子”</span>
<span style="color: #800080;">11</span>  p[x] ← y                <span style="color: #008000;">//</span><span style="color: #008000;"> 将 “x的父节点” 设为 “y”</span>

</span>
</pre>
<div><span style="font-size: 18px;"><a title="复制代码"><img src="%E7%BA%A2%E9%BB%91%E6%A0%91(%E4%B8%80)%E4%B9%8B%20%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D.resources/B1A611E1-C126-4568-9758-1FBBC7E73D21.gif" height="20" width="20"/></a></span></div>
</div>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">理解左旋之后，看看下面一个更鲜明的例子。你可以先不看右边的结果，自己尝试一下。</span></span></p>
<p><span style="font-size: 18px;"><a href="http://images.cnitblog.com/i/497634/201403/251734577643655.jpg"><span style="color: rgb(0, 0, 0);"><img src="%E7%BA%A2%E9%BB%91%E6%A0%91(%E4%B8%80)%E4%B9%8B%20%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D.resources/E642096C-0ABF-4EA6-AFD9-1B2B2395004D.jpg" height="357" width="1438"/></span></a></span></p>
<p><span style="font-size: 18px;"> </span></p>
<p><a name="a32"/><span style="font-size: 18px;"><strong>2. 右旋</strong></span></p>
<p><span style="font-size: 18px;"><a href="http://images.cnitblog.com/i/497634/201403/251735527958942.jpg"><img src="%E7%BA%A2%E9%BB%91%E6%A0%91(%E4%B8%80)%E4%B9%8B%20%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D.resources/C921CDAC-A737-4BA3-957F-AE7DAC609AFE.jpg" height="301" width="550"/></a></span></p>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">对x进行左旋，意味着"将x变成一个左节点"。</span></span></p>
<p><span style="font-size: 18px;"><br/>
<span style="color: #000000;">右旋的伪代码《算法导论》：参考上面的示意图和下面的伪代码，理解“红黑树T的节点y进行右旋”是如何进行的。 </span></span></p>
<div>
<div><span style="font-size: 18px;"><a title="复制代码"><img src="%E7%BA%A2%E9%BB%91%E6%A0%91(%E4%B8%80)%E4%B9%8B%20%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D.resources/B1A611E1-C126-4568-9758-1FBBC7E73D21.gif" height="20" width="20"/></a></span></div>
<pre>
<span style="font-size: 18px;">
RIGHT-<span style="color: #000000;">ROTATE(T, y)  
</span><span style="color: #800080;">01</span>  x ← left[y]             <span style="color: #008000;">//</span><span style="color: #008000;"> 前提：这里假设y的左孩子为x。下面开始正式操作</span>
<span style="color: #800080;">02</span>  left[y] ← right[x]      <span style="color: #008000;">//</span><span style="color: #008000;"> 将 “x的右孩子” 设为 “y的左孩子”，即 将β设为y的左孩子</span>
<span style="color: #800080;">03</span>  p[right[x]] ← y         <span style="color: #008000;">//</span><span style="color: #008000;"> 将 “y” 设为 “x的右孩子的父亲”，即 将β的父亲设为y</span>
<span style="color: #800080;">04</span>  p[x] ← p[y]             <span style="color: #008000;">//</span><span style="color: #008000;"> 将 “y的父亲” 设为 “x的父亲”</span>
<span style="color: #800080;">05</span>  <span style="color: #0000ff;">if</span> p[y] =<span style="color: #000000;"> nil[T]       
</span><span style="color: #800080;">06</span>  then root[T] ← x                 <span style="color: #008000;">//</span><span style="color: #008000;"> 情况1：如果 “y的父亲” 是空节点，则将x设为根节点</span>
<span style="color: #800080;">07</span>  <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> y =<span style="color: #000000;"> right[p[y]]  
</span><span style="color: #800080;">08</span>            then right[p[y]] ← x   <span style="color: #008000;">//</span><span style="color: #008000;"> 情况2：如果 y是它父节点的右孩子，则将x设为“y的父节点的左孩子”</span>
<span style="color: #800080;">09</span>            <span style="color: #0000ff;">else</span> left[p[y]] ← x    <span style="color: #008000;">//</span><span style="color: #008000;"> 情况3：(y是它父节点的左孩子) 将x设为“y的父节点的左孩子”</span>
<span style="color: #800080;">10</span>  right[x] ← y            <span style="color: #008000;">//</span><span style="color: #008000;"> 将 “y” 设为 “x的右孩子”</span>
<span style="color: #800080;">11</span>  p[y] ← x                <span style="color: #008000;">//</span><span style="color: #008000;"> 将 “y的父节点” 设为 “x”</span>

</span>
</pre>
<div><span style="font-size: 18px;"><a title="复制代码"><img src="%E7%BA%A2%E9%BB%91%E6%A0%91(%E4%B8%80)%E4%B9%8B%20%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D.resources/B1A611E1-C126-4568-9758-1FBBC7E73D21.gif" height="20" width="20"/></a></span></div>
</div>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">理解右旋之后，看看下面一个更鲜明的例子。你可以先不看右边的结果，自己尝试一下。</span></span></p>
<p><span style="font-size: 18px;"><a href="http://images.cnitblog.com/i/497634/201403/251737465769614.jpg"><img src="%E7%BA%A2%E9%BB%91%E6%A0%91(%E4%B8%80)%E4%B9%8B%20%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D.resources/A1EADA58-2C77-4F74-9239-0171B860A65E.jpg" height="361" width="1438"/></a></span></p>
<p><span style="font-size: 18px;"><br/>
<span style="color: rgb(0, 0, 0);"><strong>旋转总结</strong>：</span></span></p>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">(01) 左旋 和 右旋 是相对的两个概念，原理类似。理解一个也就理解了另一个。</span></span></p>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">(02) 下面谈谈如何区分 左旋 和 右旋。</span><br/>
<span style="color: rgb(0, 0, 0);">在实际应用中，若没有彻底理解 左旋 和 右旋，可能会将它们混淆。下面谈谈我对如何区分 左旋 和 右旋 的理解。</span></span></p>
<p><span style="font-size: 18px;"> </span></p>
<p><span style="font-size: 18px;"><span style="color: #ff0000;"><a name="a33"/><span style="color: #000000;"><strong>3. 区分 左旋 和 右旋</strong></span></span></span></p>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">仔细观察上面"左旋"和"右旋"的示意图。我们能清晰的发现，它们是对称的。无论是左旋还是右旋，被旋转的树，在旋转前是二叉查找树，并且旋转之后仍然是一颗二叉查找树。</span></span></p>
<p><span style="font-size: 18px;"><a href="http://images.cnitblog.com/i/497634/201403/251739385617803.jpg"><img src="%E7%BA%A2%E9%BB%91%E6%A0%91(%E4%B8%80)%E4%B9%8B%20%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D.resources/72E8EBDD-24EF-4E6F-8527-CCED54291824.jpg" height="301" width="550"/></a></span></p>
<p><span style="font-size: 18px;"> </span></p>
<p><span style="font-size: 18px;"> </span></p>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);"><strong>左旋示例图</strong>(以x为节点进行左旋)：</span></span></p>
<div>
<pre>
<span style="font-size: 18px;"><span style="color: #000000;">                               z
   x                          </span>/                  
  / \      --(左旋)--&gt;<span style="color: #000000;">       x
 y   z                      </span>/<span style="color: #000000;">
                           y</span>

</span>
</pre></div>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">对x进行左旋，意味着，将“x的右孩子”设为“x的父亲节点”；即，将 x变成了一个左节点(x成了为z的左孩子)！。 因此，<strong>左旋中的“左”，意味着“被旋转的节点将变成一个左节点”</strong>。</span></span></p>
<p><span style="font-size: 18px;"><br/>
<span style="color: rgb(0, 0, 0);"><strong>右旋示例图</strong>(以x为节点进行右旋)：</span></span></p>
<div>
<pre>
<span style="font-size: 18px;"><span style="color: #000000;">                               y
   x                            \                 
  </span>/ \      --(右旋)--&gt;<span style="color: #000000;">           x
 y   z                            \
                                   z</span>

</span>
</pre></div>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">对x进行右旋，意味着，将“x的左孩子”设为“x的父亲节点”；即，将 x变成了一个右节点(x成了为y的右孩子)！ 因此，<strong>右旋中的“右”，意味着“被旋转的节点将变成一个右节点”</strong>。</span></span></p>
<p><span style="font-size: 18px;"> </span></p>
<h3><span style="font-size: 18px;"><strong><span style="font-family: 黑体; color: rgb(0, 0, 0);"><a name="aa5"/>红黑树的基本操作(二) 添加</span></strong></span></h3>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">将一个节点插入到红黑树中，需要执行哪些步骤呢？首先，将红黑树当作一颗二叉查找树，将节点插入；然后，将节点着色为红色；最后，通过旋转和重新着色等方法来修正该树，使之重新成为一颗红黑树。详细描述如下：</span></span></p>
<p><span style="font-size: 18px;"><strong><span style="color: rgb(0, 0, 0);">第一步: 将红黑树当作一颗二叉查找树，将节点插入。</span></strong><br/>
<span style="color: rgb(0, 0, 0);">       红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。此外，无论是左旋还是右旋，若旋转之前这 棵树是二叉查找树，旋转之后它一定还是二叉查找树。这也就意味着，任何的旋转和重新着色操作，都不会改变它仍然是一颗二叉查找树的事实。</span><br/>
<span style="color: rgb(0, 0, 0);">       好吧？那接下来，我们就来想方设法的旋转以及重新着色，使这颗树重新成为红黑树！</span></span></p>
<p><span style="font-size: 18px;"><strong><span style="color: rgb(0, 0, 0);">第二步：将插入的节点着色为"红色"。</span></strong><br/>
<span style="color: rgb(0, 0, 0);">       为什么着色成红色，而不是黑色呢？为什么呢？在回答之前，我们需要重新温习一下红黑树的特性：</span><br/>
<span style="color: rgb(0, 128, 0);">(1) 每个节点或者是黑色，或者是红色。</span><br/>
<span style="color: rgb(0, 128, 0);">(2) 根节点是黑色。</span><br/>
<span style="color: rgb(0, 128, 0);">(3) 每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！]</span><br/>
<span style="color: rgb(0, 128, 0);">(4) 如果一个节点是红色的，则它的子节点必须是黑色的。</span><br/>
<span style="color: rgb(0, 128, 0);">(5) 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</span><br/>
<span style="color: rgb(0, 0, 0);">       将插入的节点着色为红色，不会违背"特性(5)"！少违背一条特性，就意味着我们需要处理的情况越少。接下来，就要努力的让这棵树满足其它性质即可；满足了的话，它就又是一颗红黑树了。o(∩∩)o...哈哈</span></span></p>
<p><span style="font-size: 18px;"><strong><span style="color: rgb(0, 0, 0);">第三步: 通过一系列的旋转或着色等操作，使之重新成为一颗红黑树。</span></strong><br/>
<span style="color: rgb(0, 0, 0);">       第二步中，将插入节点着色为"红色"之后，不会违背"特性(5)"。那它到底会违背哪些特性呢？</span><br/>
<span style="color: rgb(0, 0, 0);">       对于"特性(1)"，显然不会违背了。因为我们已经将它涂成红色了。</span><br/>
<span style="color: rgb(0, 0, 0);">       对于"特性(2)"，显然也不会违背。在第一步中，我们是将红黑树当作二叉查找树，然后执行的插入操作。而根据二叉查找数的特点，插入操作不会改变根节点。所以，根节点仍然是黑色。</span><br/>
<span style="color: rgb(0, 0, 0);">       对于"特性(3)"，显然不会违背了。这里的叶子节点是指的空叶子节点，插入非空节点并不会对它们造成影响。</span><br/>
<span style="color: rgb(0, 0, 0);">       对于"特性(4)"，是有可能违背的！</span><br/>
<span style="color: rgb(0, 0, 0);">       那接下来，想办法使之"满足特性(4)"，就可以将树重新构造成红黑树了。</span></span></p>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">下面看看代码到底是怎样实现这三步的。</span></span></p>
<p><span style="font-size: 18px;"> </span></p>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">添加操作的伪代码《算法导论》</span></span></p>
<div>
<div><span style="font-size: 18px;"><a title="复制代码"><img src="%E7%BA%A2%E9%BB%91%E6%A0%91(%E4%B8%80)%E4%B9%8B%20%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D.resources/B1A611E1-C126-4568-9758-1FBBC7E73D21.gif" height="20" width="20"/></a></span></div>
<pre>
<span style="font-size: 18px;">
RB-<span style="color: #000000;">INSERT(T, z)  
</span><span style="color: #800080;">01</span>  y ← nil[T]                        <span style="color: #008000;">//</span><span style="color: #008000;"> 新建节点“y”，将y设为空节点。</span>
<span style="color: #800080;">02</span>  x ← root[T]                       <span style="color: #008000;">//</span><span style="color: #008000;"> 设“红黑树T”的根节点为“x”</span>
<span style="color: #800080;">03</span>  <span style="color: #0000ff;">while</span> x ≠ nil[T]                  <span style="color: #008000;">//</span><span style="color: #008000;"> 找出要插入的节点“z”在二叉树T中的位置“y”</span>
<span style="color: #800080;">04</span>      <span style="color: #0000ff;">do</span><span style="color: #000000;"> y ← x                      
</span><span style="color: #800080;">05</span>         <span style="color: #0000ff;">if</span> key[z] &lt;<span style="color: #000000;"> key[x]  
</span><span style="color: #800080;">06</span><span style="color: #000000;">            then x ← left[x]  
</span><span style="color: #800080;">07</span>            <span style="color: #0000ff;">else</span><span style="color: #000000;"> x ← right[x]  
</span><span style="color: #800080;">08</span>  p[z] ← y                          <span style="color: #008000;">//</span><span style="color: #008000;"> 设置 “z的父亲” 为 “y”</span>
<span style="color: #800080;">09</span>  <span style="color: #0000ff;">if</span> y =<span style="color: #000000;"> nil[T]                     
</span><span style="color: #800080;">10</span>     then root[T] ← z               <span style="color: #008000;">//</span><span style="color: #008000;"> 情况1：若y是空节点，则将z设为根</span>
<span style="color: #800080;">11</span>     <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> key[z] &lt;<span style="color: #000000;"> key[y]        
</span><span style="color: #800080;">12</span>             then left[y] ← z       <span style="color: #008000;">//</span><span style="color: #008000;"> 情况2：若“z所包含的值” &lt; “y所包含的值”，则将z设为“y的左孩子”</span>
<span style="color: #800080;">13</span>             <span style="color: #0000ff;">else</span> right[y] ← z      <span style="color: #008000;">//</span><span style="color: #008000;"> 情况3：(“z所包含的值” &gt;= “y所包含的值”)将z设为“y的右孩子” </span>
<span style="color: #800080;">14</span>  left[z] ← nil[T]                  <span style="color: #008000;">//</span><span style="color: #008000;"> z的左孩子设为空</span>
<span style="color: #800080;">15</span>  right[z] ← nil[T]                 <span style="color: #008000;">//</span><span style="color: #008000;"> z的右孩子设为空。至此，已经完成将“节点z插入到二叉树”中了。</span>
<span style="color: #800080;">16</span>  color[z] ← RED                    <span style="color: #008000;">//</span><span style="color: #008000;"> 将z着色为“红色”</span>
<span style="color: #800080;">17</span>  RB-INSERT-FIXUP(T, z)             <span style="color: #008000;">//</span><span style="color: #008000;"> 通过RB-INSERT-FIXUP对红黑树的节点进行颜色修改以及旋转，让树T仍然是一颗红黑树</span>

</span>
</pre>
<div><span style="font-size: 18px;"><a title="复制代码"><img src="%E7%BA%A2%E9%BB%91%E6%A0%91(%E4%B8%80)%E4%B9%8B%20%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D.resources/B1A611E1-C126-4568-9758-1FBBC7E73D21.gif" height="20" width="20"/></a></span></div>
</div>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">结合伪代码以及为代码上面的说明，先理解RB-INSERT。理解了RB-INSERT之后，我们接着对 RB-INSERT-FIXUP的伪代码进行说明。</span></span></p>
<p><span style="font-size: 18px;">添加修正操作的伪代码《算法导论》</span></p>
<div>
<div><span style="font-size: 18px;"><a title="复制代码"><img src="%E7%BA%A2%E9%BB%91%E6%A0%91(%E4%B8%80)%E4%B9%8B%20%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D.resources/B1A611E1-C126-4568-9758-1FBBC7E73D21.gif" height="20" width="20"/></a></span></div>
<pre>
<span style="font-size: 18px;">
RB-INSERT-<span style="color: #000000;">FIXUP(T, z)
</span><span style="color: #800080;">01</span> <span style="color: #0000ff;">while</span> color[p[z]] = RED                                                  <span style="color: #008000;">//</span><span style="color: #008000;"> 若“当前节点(z)的父节点是红色”，则进行以下处理。</span>
<span style="color: #800080;">02</span>     <span style="color: #0000ff;">do</span> <span style="color: #0000ff;">if</span> p[z] = left[p[p[z]]]                                           <span style="color: #008000;">//</span><span style="color: #008000;"> 若“z的父节点”是“z的祖父节点的左孩子”，则进行以下处理。</span>
<span style="color: #800080;">03</span>           then y ← right[p[p[z]]]                                        <span style="color: #008000;">//</span><span style="color: #008000;"> 将y设置为“z的叔叔节点(z的祖父节点的右孩子)”</span>
<span style="color: #800080;">04</span>                <span style="color: #0000ff;">if</span> color[y] = RED                                         <span style="color: #008000;">//</span><span style="color: #008000;"> Case 1条件：叔叔是红色</span>
<span style="color: #800080;">05</span>                   then color[p[z]] ← BLACK                    ▹ Case <span style="color: #800080;">1</span>   <span style="color: #008000;">//</span><span style="color: #008000;">  (01) 将“父节点”设为黑色。</span>
<span style="color: #800080;">06</span>                        color[y] ← BLACK                       ▹ Case <span style="color: #800080;">1</span>   <span style="color: #008000;">//</span><span style="color: #008000;">  (02) 将“叔叔节点”设为黑色。</span>
<span style="color: #800080;">07</span>                        color[p[p[z]]] ← RED                   ▹ Case <span style="color: #800080;">1</span>   <span style="color: #008000;">//</span><span style="color: #008000;">  (03) 将“祖父节点”设为“红色”。</span>
<span style="color: #800080;">08</span>                        z ← p[p[z]]                            ▹ Case <span style="color: #800080;">1</span>   <span style="color: #008000;">//</span><span style="color: #008000;">  (04) 将“祖父节点”设为“当前节点”(红色节点)</span>
<span style="color: #800080;">09</span>                   <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> z = right[p[z]]                                <span style="color: #008000;">//</span><span style="color: #008000;"> Case 2条件：叔叔是黑色，且当前节点是右孩子</span>
<span style="color: #800080;">10</span>                           then z ← p[z]                       ▹ Case <span style="color: #800080;">2</span>   <span style="color: #008000;">//</span><span style="color: #008000;">  (01) 将“父节点”作为“新的当前节点”。</span>
<span style="color: #800080;">11</span>                                LEFT-ROTATE(T, z)              ▹ Case <span style="color: #800080;">2</span>   <span style="color: #008000;">//</span><span style="color: #008000;">  (02) 以“新的当前节点”为支点进行左旋。</span>
<span style="color: #800080;">12</span>                           color[p[z]] ← BLACK                 ▹ Case <span style="color: #800080;">3</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> Case 3条件：叔叔是黑色，且当前节点是左孩子。(01) 将“父节点”设为“黑色”。</span>
<span style="color: #800080;">13</span>                           color[p[p[z]]] ← RED                ▹ Case <span style="color: #800080;">3</span>   <span style="color: #008000;">//</span><span style="color: #008000;">  (02) 将“祖父节点”设为“红色”。</span>
<span style="color: #800080;">14</span>                           RIGHT-ROTATE(T, p[p[z]])            ▹ Case <span style="color: #800080;">3</span>   <span style="color: #008000;">//</span><span style="color: #008000;">  (03) 以“祖父节点”为支点进行右旋。</span>
<span style="color: #800080;">15</span>        <span style="color: #0000ff;">else</span> (same <span style="color: #0000ff;">as</span> then clause with <span style="color: #800000;">"</span><span style="color: #800000;">right</span><span style="color: #800000;">"</span> and <span style="color: #800000;">"</span><span style="color: #800000;">left</span><span style="color: #800000;">"</span> exchanged)      <span style="color: #008000;">//</span><span style="color: #008000;"> 若“z的父节点”是“z的祖父节点的右孩子”，将上面的操作中“right”和“left”交换位置，然后依次执行。</span>
<span style="color: #800080;">16</span> color[root[T]] ← BLACK 

</span>
</pre>
<div><span style="font-size: 18px;"><a title="复制代码"><img src="%E7%BA%A2%E9%BB%91%E6%A0%91(%E4%B8%80)%E4%B9%8B%20%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D.resources/B1A611E1-C126-4568-9758-1FBBC7E73D21.gif" height="20" width="20"/></a></span></div>
</div>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">根据被插入节点的父节点的情况，可以将"当节点z被着色为红色节点，并插入二叉树"划分为三种情况来处理。</span><br/>
<span style="color: rgb(0, 0, 0);">① 情况说明：被插入的节点是根节点。</span><br/>
<span style="color: rgb(0, 0, 0);">    处理方法：直接把此节点涂为黑色。</span><br/>
<span style="color: rgb(0, 0, 0);">② 情况说明：被插入的节点的父节点是黑色。</span><br/>
<span style="color: rgb(0, 0, 0);">    处理方法：什么也不需要做。节点被插入后，仍然是红黑树。</span><br/>
<span style="color: rgb(0, 0, 0);">③ 情况说明：被插入的节点的父节点是红色。</span><br/>
<span style="color: rgb(0, 0, 0);">    处理方法：那么，该情况与红黑树的“特性(5)”相冲突。这种情况下，被插入节点是一定存在非空祖父节点的；进一步的讲，被插入节点也一定存在叔叔节点 (即使叔叔节点为空，我们也视之为存在，空节点本身就是黑色节点)。理解这点之后，我们依据"叔叔节点的情况"，将这种情况进一步划分为3种情况 (Case)。</span></span></p>
<table style="border: 1px solid #000000;width:1144px;" border="1">
<tr style="background-color: #7d7d82;">
<td style="width:4.195804195804196%;"><span style="font-size: 18px;"> </span></td>
<td style="width:49.47552447552447%;"><span style="font-size: 18px;"><strong><span style="color: rgb(0, 0, 0);">现象说明</span></strong></span></td>
<td style="width:45.71678321678322%;"><span style="font-size: 18px;"><strong><span style="color: rgb(0, 0, 0);">处理策略</span></strong></span></td>
</tr>
<tr>
<td style=""><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">Case 1</span></span></td>
<td><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">当前节点的父节点是红色，且当前节点的祖父节点的另一个子节点（叔叔节点）也是红色。</span></span></td>
<td>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">(01) 将“父节点”设为黑色。</span><br/>
<span style="color: rgb(0, 0, 0);">(02) 将“叔叔节点”设为黑色。</span><br/>
<span style="color: rgb(0, 0, 0);">(03) 将“祖父节点”设为“红色”。</span><br/>
<span style="color: rgb(0, 0, 0);">(04) 将“祖父节点”设为“当前节点”(红色节点)；即，之后继续对“当前节点”进行操作。</span></span></p>
</td>
</tr>
<tr>
<td><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">Case 2</span></span></td>
<td><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的右孩子</span></span></td>
<td>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">(01) 将“父节点”作为“新的当前节点”。</span><br/>
<span style="color: rgb(0, 0, 0);">(02) 以“新的当前节点”为支点进行左旋。</span></span></p>
</td>
</tr>
<tr>
<td><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">Case 3</span></span></td>
<td><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子</span></span></td>
<td>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">(01) 将“父节点”设为“黑色”。</span><br/>
<span style="color: rgb(0, 0, 0);">(02) 将“祖父节点”设为“红色”。</span><br/>
<span style="color: rgb(0, 0, 0);">(03) 以“祖父节点”为支点进行右旋。</span></span></p>
</td>
</tr>
</table>
<p><span style="font-size: 18px;">上面三种情况(Case)处理问题的核心思路都是：<span style="color: #ff0000;">将红色的节点移到根节点；然后，将根节点设为黑色</span>。下面对它们详细进行介绍。</span></p>
<p><span style="font-size: 18px;"> </span></p>
<p><span style="font-size: 18px;"><strong><span style="color: rgb(0, 0, 0);">1. (Case 1)叔叔是红色</span></strong></span></p>
<p><span style="font-size: 18px;"><strong><span style="color: rgb(0, 0, 0);">1.1 现象说明</span></strong><br/>
<span style="color: rgb(0, 0, 0);">当前节点(即，被插入节点)的父节点是红色，且当前节点的祖父节点的另一个子节点（叔叔节点）也是红色。</span></span></p>
<p><span style="font-size: 18px;"><strong><span style="color: rgb(0, 0, 0);">1.2 处理策略</span></strong><br/>
<span style="color: rgb(0, 0, 0);">(01) 将“父节点”设为黑色。</span><br/>
<span style="color: rgb(0, 0, 0);">(02) 将“叔叔节点”设为黑色。</span><br/>
<span style="color: rgb(0, 0, 0);">(03) 将“祖父节点”设为“红色”。</span><br/>
<span style="color: rgb(0, 0, 0);">(04) 将“祖父节点”设为“当前节点”(红色节点)；即，之后继续对“当前节点”进行操作。</span></span></p>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">    <strong>下面谈谈为什么要这样处理。</strong>(建议理解的时候，通过下面的图进行对比)</span><br/>
<span style="color: rgb(0, 0, 0);">    “当前节点”和“父节点”都是红色，违背“特性(4)”。所以，将“父节点”设置“黑色”以解决这个问题。</span><br/>
<span style="color: rgb(0, 0, 0);">    但是，将“父节点”由“红色”变成“黑色”之后，违背了“特性(5)”：因为，包含“父节点”的分支的黑色节点的总数增加了1。  解决这个问题的办法是：将“祖父节点”由“黑色”变成红色，同时，将“叔叔节点”由“红色”变成“黑色”。关于这里，说明几点：第一，为什么“祖父节 点”之前是黑色？这个应该很容易想明白，因为在变换操作之前，该树是红黑树，“父节点”是红色，那么“祖父节点”一定是黑色。 第二，为什么将“祖父节点”由“黑色”变成红色，同时，将“叔叔节点”由“红色”变成“黑色”；能解决“包含‘父节点’的分支的黑色节点的总数增加了1” 的问题。这个道理也很简单。“包含‘父节点’的分支的黑色节点的总数增加了1” 同时也意味着 “包含‘祖父节点’的分支的黑色节点的总数增加了1”，既然这样，我们通过将“祖父节点”由“黑色”变成“红色”以解决“包含‘祖父节点’的分支的黑色节 点的总数增加了1”的问题； 但是，这样处理之后又会引起另一个问题“包含‘叔叔’节点的分支的黑色节点的总数减少了1”，现在我们已知“叔叔节点”是“红色”，将“叔叔节点”设为 “黑色”就能解决这个问题。 所以，将“祖父节点”由“黑色”变成红色，同时，将“叔叔节点”由“红色”变成“黑色”；就解决了该问题。</span><br/>
<span style="color: rgb(0, 0, 0);">    按照上面的步骤处理之后：当前节点、父节点、叔叔节点之间都不会违背红黑树特性，但祖父节点却不一定。若此时，祖父节点是根节点，直接将祖父节点设为“黑 色”，那就完全解决这个问题了；若祖父节点不是根节点，那我们需要将“祖父节点”设为“新的当前节点”，接着对“新的当前节点”进行分析。</span></span></p>
<p><span style="font-size: 18px;"><strong><span style="color: #000000;">1.3 示意图</span></strong></span></p>
<p><span style="font-size: 18px;"><a href="http://images.cnitblog.com/i/497634/201403/251759273578917.jpg"><strong><span style="color: #000000;"><img src="%E7%BA%A2%E9%BB%91%E6%A0%91(%E4%B8%80)%E4%B9%8B%20%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D.resources/53706639-2C81-467E-ABBE-AAE0ADF58738.jpg" height="522" width="1608"/></span></strong></a></span></p>
<p><span style="font-size: 18px;"> </span></p>
<p><span style="font-size: 18px;"><strong><span style="color: rgb(0, 0, 0);">2. (Case 2)叔叔是黑色，且当前节点是右孩子</span></strong></span></p>
<p><span style="font-size: 18px;"><strong><span style="color: rgb(0, 0, 0);">2.1 现象说明</span></strong><br/>
<span style="color: rgb(0, 0, 0);">当前节点(即，被插入节点)的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的右孩子</span></span></p>
<p><span style="font-size: 18px;"><strong><span style="color: rgb(0, 0, 0);">2.2 处理策略</span></strong><br/>
<span style="color: rgb(0, 0, 0);">(01) 将“父节点”作为“新的当前节点”。</span><br/>
<span style="color: rgb(0, 0, 0);">(02) 以“新的当前节点”为支点进行左旋。</span></span></p>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">      <strong>下面谈谈为什么要这样处理。</strong>(建议理解的时候，通过下面的图进行对比)</span><br/>
<span style="color: rgb(0, 0, 0);">      首先，将“父节点”作为“新的当前节点”；接着，以“新的当前节点”为支点进行左旋。 为了便于理解，我们先说明第(02)步，再说明第(01)步；为了便于说明，我们设置“父节点”的代号为F(Father)，“当前节点”的代号为S(Son)。</span><br/>
<span style="color: rgb(0, 0, 0);">为 什么要“以F为支点进行左旋”呢？根据已知条件可知：S是F的右孩子。而之前我们说过，我们处理红黑树的核心思想：将红色的节点移到根节点；然后，将根节 点设为黑色。既然是“将红色的节点移到根节点”，那就<span style="color: rgb(255, 38, 0);">是说要不断的将破坏红黑树特性的红色节点上移(即向根方向移动)</span>。 而S又是一个右孩子，因此，我们可以通过“左旋”来将S上移！</span><br/>
<span style="color: rgb(0, 0, 0);">      按照上面的步骤(以F为支点进行左旋)处理之后：若S变成了根节点，那么直接将其设为“黑色”，就完全解决问题了；若S不是根节点，那我们需要执行步骤 (01)，即“将F设为‘新的当前节点’”。那为什么不继续以S为新的当前节点继续处理，而需要以F为新的当前节点来进行处理呢？这是因为“左旋”之 后，F变成了S的“子节点”，即S变成了F的父节点；而我们处理问题的时候，需要从下至上(由叶到根)方向进行处理；也就是说，<span style="color: rgb(255, 38, 0);">必须先解决“孩子”的问 题</span>，再解决“父亲”的问题；所以，我们执行步骤(01)：将“父节点”作为“新的当前节点”。</span></span></p>
</div>
<div><br/></div>
<div><span style="font-size: 18px;"><strong><span style="color: rgb(0, 0, 0);">2.2 示意图（）</span></strong></span></div>
<div>
<p><span style="font-size: 18px;"><a href="http://images.cnitblog.com/i/497634/201403/251801031546918.jpg"><strong><span style="color: rgb(0, 0, 0);"><img src="%E7%BA%A2%E9%BB%91%E6%A0%91(%E4%B8%80)%E4%B9%8B%20%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D.resources/8F4275BA-64EC-4102-B103-70E8720B0395.jpg" height="507" width="1665"/></span></strong></a></span></p>
<p><span style="font-size: 18px;"> </span></p>
<p><span style="font-size: 18px;"><strong><span style="color: rgb(0, 0, 0);">3. (Case 3)叔叔是黑色，且当前节点是左孩子</span></strong></span></p>
<p><span style="font-size: 18px;"><strong><span style="color: rgb(0, 0, 0);">3.1 现象说明</span></strong><br/>
<span style="color: rgb(0, 0, 0);">当前节点(即，被插入节点)的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子</span></span></p>
<p><span style="font-size: 18px;"><strong><span style="color: rgb(0, 0, 0);">3.2 处理策略</span></strong><br/>
<span style="color: rgb(0, 0, 0);">(01) 将“父节点”设为“黑色”。</span><br/>
<span style="color: rgb(0, 0, 0);">(02) 将“祖父节点”设为“红色”。</span><br/>
<span style="color: rgb(0, 0, 0);">(03) 以“祖父节点”为支点进行右旋。</span></span></p>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">      <strong>下面谈谈为什么要这样处理。</strong>(建议理解的时候，通过下面的图进行对比)</span><br/>
<span style="color: rgb(0, 0, 0);">      为了便于说明，我们设置“当前节点”为S(Original Son)，“兄弟节点”为B(Brother)，“叔叔节点”为U(Uncle)，“父节点”为F(Father)，祖父节点为G(Grand-Father)。</span><br/>
<span style="color: rgb(0, 0, 0);">      S和F都是红色，违背了红黑树的“特性(4)”，我们可以将F由“红色”变为“黑色”，就解决了“违背‘特性(4)’”的问题；但却引起了其它问题：违背 特性(5)，因为将F由红色改为黑色之后，所有经过F的分支的黑色节点的个数增加了1。那我们如何解决“所有经过F的分支的黑色节点的个数增加了1”的问 题呢？ 我们可以通过“将G由黑色变成红色”，同时“以G为支点进行右旋”来解决。</span></span></p>
<p><span style="font-size: 18px;"><strong><span style="color: rgb(0, 0, 0);">2.3 示意图</span></strong></span></p>
<p><span style="font-size: 18px;"><a href="http://images.cnitblog.com/i/497634/201404/170945094945387.jpg"><img src="%E7%BA%A2%E9%BB%91%E6%A0%91(%E4%B8%80)%E4%B9%8B%20%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D.resources/3020213C-6F69-400D-85DC-937FD7A4A5CC.jpg" height="506" width="1664"/></a></span></p>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">提示：上面的进行Case 3处理之后，再将节点"120"当作当前节点，就变成了Case 2的情况。</span></span></p>
<p><span style="font-size: 18px;"> </span></p>
<h3><a name="a35"/><span style="font-size: 18px;"><strong><span style="font-family: 黑体; color: rgb(0, 0, 0);">红黑树的基本操作(三) 删除</span></strong></span></h3>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">将红黑树内的某一个节点删除。需要执行的操作依次是：首先，将红黑树当作一颗二叉查找树，将该节点从二叉查找树中删除；然后，通过"旋转和重新着色"等一系列来修正该树，使之重新成为一棵红黑树。详细描述如下：</span></span></p>
<p><span style="font-size: 18px;"><strong><span style="color: rgb(0, 0, 0);">第一步：将红黑树当作一颗二叉查找树，将节点删除。</span></strong><br/>
<span style="color: rgb(0, 0, 0);">       这和"删除常规二叉查找树中删除节点的方法是一样的"。分3种情况：</span><br/>
<span style="color: rgb(0, 0, 0);">       ① 被删除节点没有儿子，即为叶节点。那么，直接将该节点删除就OK了。</span><br/>
<span style="color: rgb(0, 0, 0);">       ② 被删除节点只有一个儿子。那么，直接删除该节点，并用该节点的唯一子节点顶替它的位置。</span><br/>
<span style="color: rgb(0, 0, 0);">       ③ 被删除节点有两个儿子。那么，先找出它的后继节点；然后把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。在这里，后继节点 相当于替身，在将后继节点的内容复制给"被删除节点"之后，再将后继节点删除。这样就巧妙的将问题转换为"删除后继节点"的情况了，下面就考虑后继节点。 在"被删除节点"有两个非空子节点的情况下，它的后继节点不可能是双子非空。既然"的后继节点"不可能双子都非空，就意味着"该节点的后继节点"要么没有 儿子，要么只有一个儿子。若没有儿子，则按"情况① "进行处理；若只有一个儿子，则按"情况② "进行处理。</span></span></p>
<p><span style="font-size: 18px;"><strong><span style="color: rgb(0, 0, 0);">第二步：通过"旋转和重新着色"等一系列来修正该树，使之重新成为一棵红黑树。</span></strong><br/>
<span style="color: rgb(0, 0, 0);">       因为"第一步"中删除节点之后，可能会违背红黑树的特性。所以需要通过"旋转和重新着色"来修正该树，使之重新成为一棵红黑树。</span></span></p>
<p><span style="font-size: 18px;"> </span></p>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">删除操作的伪代码《算法导论》</span></span></p>
</div>
<div>
<div>
<div><span style="font-size: 18px;"><a title="复制代码"><img src="%E7%BA%A2%E9%BB%91%E6%A0%91(%E4%B8%80)%E4%B9%8B%20%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D.resources/B1A611E1-C126-4568-9758-1FBBC7E73D21.gif" height="20" width="20"/></a></span></div>
</div>
<div><br/></div>
<div><span style="font-size: 18px;"><br/></span></div>
<div><span style="font-size: 18px;">RB-<span style="color: #000000;">DELETE(T, z)//z是要删除的值，y是后继结点（替身），x是y的孩子</span></span></div>
<div><span style="font-size: 18px;"><span style="color: #800080;">01</span> <span style="color: #0000ff;">if</span> left[z] = nil[T] or right[z] =<span style="color: #000000;"> nil[T]         <br/></span><span style="color: #800080;">02</span>    then y ← z                                  <span style="color: #008000;">//</span><span style="color: #008000;"> 若“z的左孩子” 或 “z的右孩子”为空，则将“z”赋值给 “y”；</span><br/>
<span style="color: #800080;">03</span>    <span style="color: #0000ff;">else</span> y ← TREE-SUCCESSOR(z)                  <span style="color: #008000;">//</span><span style="color: #008000;"> 否则，将“z的后继节点”赋值给 “y”。</span><br/>
<span style="color: #800080;">04</span> <span style="color: #0000ff;">if</span><span style="color: #000000;"> left[y] ≠ nil[T]<br/></span><span style="color: #800080;">05</span>    then x ← left[y]                            <span style="color: #008000;">//</span><span style="color: #008000;"> 若“y的左孩子” 不为空，则将“y的左孩子” 赋值给 “x”；</span><br/>
<span style="color: #800080;">06</span>    <span style="color: #0000ff;">else</span> x ← right[y]                           <span style="color: #008000;">//</span><span style="color: #008000;"> 否则，“y的右孩子” 赋值给 “x”。</span><br/>
<span style="color: #800080;">07</span> p[x] ← p[y]                                    <span style="color: #008000;">//</span><span style="color: #008000;"> 将“y的父节点” 设置为 “x的父节点”</span><br/>
<span style="color: #800080;">08</span> <span style="color: #0000ff;">if</span> p[y] =<span style="color: #000000;"> nil[T]                               <br/></span><span style="color: #800080;">09</span>    then root[T] ← x                            <span style="color: #008000;">//</span><span style="color: #008000;"> 情况1：若“y的父节点” 为空，则设置“x” 为 “根节点”。</span><br/>
<span style="color: #800080;">10</span>    <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> y =<span style="color: #000000;"> left[p[y]]                   <br/></span> <span style="color: #800080;">11</span>            then left[p[y]] ← x                 <span style="color: #008000;">//</span><span style="color: #008000;"> 情况2：若“y是它父节点的左孩子”，则设置“x” 为 “y的父节点的左孩子”</span><br/>
<span style="color: #800080;">12</span>            <span style="color: #0000ff;">else</span> right[p[y]] ← x                <span style="color: #008000;">//</span><span style="color: #008000;"> 情况3：若“y是它父节点的右孩子”，则设置“x” 为 “y的父节点的右孩子”</span><br/>
<span style="color: #800080;">13</span> <span style="color: #0000ff;">if</span><span style="color: #000000;"> y ≠ z                                   <br/></span> <span style="color: #800080;">14</span>    then key[z] ← key[y]                        <span style="color: #008000;">//</span><span style="color: #008000;"> 若“y的值” 赋值给 “z”。注意：这里只拷贝z的值给y，而没有拷贝z的颜色！！！</span><br/>
<span style="color: #800080;">15</span>         copy y<span style="color: #800000;">'</span><span style="color: #800000;">s satellite data into z         </span><br/>
<span style="color: #800080;">16</span> <span style="color: #0000ff;">if</span> color[y] =<span style="color: #000000;"> BLACK                           <br/></span> <span style="color: #800080;">17</span>    then RB-DELETE-FIXUP(T, x)                  <span style="color: #008000;">//</span><span style="color: #008000;"> 若“y为黑节点”，则调用</span><br/>
<span style="color: #800080;">18</span> <span style="color: #0000ff;">return</span> y <br/>
<br/></span></div>
<div>
<div><span style="font-size: 18px;"><a title="复制代码"><img src="%E7%BA%A2%E9%BB%91%E6%A0%91(%E4%B8%80)%E4%B9%8B%20%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D.resources/B1A611E1-C126-4568-9758-1FBBC7E73D21.gif" height="20" width="20"/></a></span></div>
</div>
<div>
<p><span style="font-size: 18px;"><span style="color: #000000;">结合伪代码以及为代码上面的说明，先理解RB-DELETE。理解了RB-DELETE之后，接着对 RB-DELETE-FIXUP的伪代码进行说明</span></span></p>
<div>
<div><span style="font-size: 18px;"><a title="复制代码"><img src="%E7%BA%A2%E9%BB%91%E6%A0%91(%E4%B8%80)%E4%B9%8B%20%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D.resources/B1A611E1-C126-4568-9758-1FBBC7E73D21.gif" height="20" width="20"/></a></span></div>
<pre>
<span style="font-size: 18px;">
RB-DELETE-<span style="color: #000000;">FIXUP(T, x)
</span><span style="color: #800080;">01</span> <span style="color: #0000ff;">while</span> x ≠ root[T] and color[x] =<span style="color: #000000;"> BLACK  
</span><span style="color: #800080;">02</span>     <span style="color: #0000ff;">do</span> <span style="color: #0000ff;">if</span> x =<span style="color: #000000;"> left[p[x]]      
</span><span style="color: #800080;">03</span>           then w ← right[p[x]]                                             <span style="color: #008000;">//</span><span style="color: #008000;"> 若 “x”是“它父节点的左孩子”，则设置 “w”为“x的叔叔”(即x为它父节点的右孩子)                                          </span>
<span style="color: #800080;">04</span>                <span style="color: #0000ff;">if</span> color[w] = RED                                           <span style="color: #008000;">//</span><span style="color: #008000;"> Case 1: x是“黑+黑”节点，x的兄弟节点是红色。(此时x的父节点和x的兄弟节点的子节点都是黑节点)。</span>
<span style="color: #800080;">05</span>                   then color[w] ← BLACK                        ▹  Case <span style="color: #800080;">1</span>   <span style="color: #008000;">//</span><span style="color: #008000;">   (01) 将x的兄弟节点设为“黑色”。</span>
<span style="color: #800080;">06</span>                        color[p[x]] ← RED                       ▹  Case <span style="color: #800080;">1</span>   <span style="color: #008000;">//</span><span style="color: #008000;">   (02) 将x的父节点设为“红色”。</span>
<span style="color: #800080;">07</span>                        LEFT-ROTATE(T, p[x])                    ▹  Case <span style="color: #800080;">1</span>   <span style="color: #008000;">//</span><span style="color: #008000;">   (03) 对x的父节点进行左旋。</span>
<span style="color: #800080;">08</span>                        w ← right[p[x]]                         ▹  Case <span style="color: #800080;">1</span>   <span style="color: #008000;">//</span><span style="color: #008000;">   (04) 左旋后，重新设置x的兄弟节点。</span>
<span style="color: #800080;">09</span>                <span style="color: #0000ff;">if</span> color[left[w]] = BLACK and color[right[w]] = BLACK       <span style="color: #008000;">//</span><span style="color: #008000;"> Case 2: x是“黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色。</span>
<span style="color: #800080;">10</span>                   then color[w] ← RED                          ▹  Case <span style="color: #800080;">2</span>   <span style="color: #008000;">//</span><span style="color: #008000;">   (01) 将x的兄弟节点设为“红色”。</span>
<span style="color: #800080;">11</span>                        x ←  p[x]                               ▹  Case <span style="color: #800080;">2</span>   <span style="color: #008000;">//</span><span style="color: #008000;">   (02) 设置“x的父节点”为“新的x节点”。</span>
<span style="color: #800080;">12</span>                   <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> color[right[w]] = BLACK                          <span style="color: #008000;">//</span><span style="color: #008000;"> Case 3: x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的。</span>
<span style="color: #800080;">13</span>                           then color[left[w]] ← BLACK          ▹  Case <span style="color: #800080;">3</span>   <span style="color: #008000;">//</span><span style="color: #008000;">   (01) 将x兄弟节点的左孩子设为“黑色”。</span>
<span style="color: #800080;">14</span>                                color[w] ← RED                  ▹  Case <span style="color: #800080;">3</span>   <span style="color: #008000;">//</span><span style="color: #008000;">   (02) 将x兄弟节点设为“红色”。</span>
<span style="color: #800080;">15</span>                                RIGHT-ROTATE(T, w)              ▹  Case <span style="color: #800080;">3</span>   <span style="color: #008000;">//</span><span style="color: #008000;">   (03) 对x的兄弟节点进行右旋。</span>
<span style="color: #800080;">16</span>                                w ← right[p[x]]                 ▹  Case <span style="color: #800080;">3</span>   <span style="color: #008000;">//</span><span style="color: #008000;">   (04) 右旋后，重新设置x的兄弟节点。</span>
<span style="color: #800080;">17</span>                         color[w] ← color[p[x]]                 ▹  Case <span style="color: #800080;">4</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> Case 4: x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的。(01) 将x父节点颜色 赋值给 x的兄弟节点。</span>
<span style="color: #800080;">18</span>                         color[p[x]] ← BLACK                    ▹  Case <span style="color: #800080;">4</span>   <span style="color: #008000;">//</span><span style="color: #008000;">   (02) 将x父节点设为“黑色”。</span>
<span style="color: #800080;">19</span>                         color[right[w]] ← BLACK                ▹  Case <span style="color: #800080;">4</span>   <span style="color: #008000;">//</span><span style="color: #008000;">   (03) 将x兄弟节点的右子节设为“黑色”。</span>
<span style="color: #800080;">20</span>                         LEFT-ROTATE(T, p[x])                   ▹  Case <span style="color: #800080;">4</span>   <span style="color: #008000;">//</span><span style="color: #008000;">   (04) 对x的父节点进行左旋。</span>
<span style="color: #800080;">21</span>                         x ← root[T]                            ▹  Case <span style="color: #800080;">4</span>   <span style="color: #008000;">//</span><span style="color: #008000;">   (05) 设置“x”为“根节点”。</span>
<span style="color: #800080;">22</span>        <span style="color: #0000ff;">else</span> (same <span style="color: #0000ff;">as</span> then clause with <span style="color: #800000;">"</span><span style="color: #800000;">right</span><span style="color: #800000;">"</span> and <span style="color: #800000;">"</span><span style="color: #800000;">left</span><span style="color: #800000;">"</span> exchanged)        <span style="color: #008000;">//</span><span style="color: #008000;"> 若 “x”是“它父节点的右孩子”，将上面的操作中“right”和“left”交换位置，然后依次执行。</span>
<span style="color: #800080;">23</span> color[x] ← BLACK   

</span>
</pre>
<div><span style="font-size: 18px;"><a title="复制代码"><img src="%E7%BA%A2%E9%BB%91%E6%A0%91(%E4%B8%80)%E4%B9%8B%20%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D.resources/B1A611E1-C126-4568-9758-1FBBC7E73D21.gif" height="20" width="20"/></a></span></div>
</div>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">下面对删除函数进行分析。在分析之前，我们再次温习一下红黑树的几个特性：</span><br/>
<span style="color: rgb(0, 128, 0);">(1) 每个节点或者是黑色，或者是红色。</span><br/>
<span style="color: rgb(0, 128, 0);">(2) 根节点是黑色。</span><br/>
<span style="color: rgb(0, 128, 0);">(3) 每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！]</span><br/>
<span style="color: rgb(0, 128, 0);">(4) 如果一个节点是红色的，则它的子节点必须是黑色的。</span><br/>
<span style="color: rgb(0, 128, 0);">(5) 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</span></span></p>
<p><span style="font-size: 18px;"><span style="color: rgb(255, 38, 0);">代码中明确说明的是从底层开始，底层只有一个孩子或者没有孩子的替身孩子开始验证红黑树。程序中把替身的值给了删除的黑色节点，但是保留了颜色，继承给了他的子节点。</span><br/>
<span style="color: rgb(0, 0, 0);">      前面我们将"删除红黑树中的节点"大致分为两步，在第一步中"将红黑树当作一颗二叉查找树，将节点删除"后，可能违反"特性(2)、(4)、(5)"三个特性。第二步需要解决上面的三个问题，进而保持红黑树的全部特性。</span><br/>
<span style="color: rgb(0, 0, 0);">      为了便于分析，我们假设"x包含一个额外的黑色"(x原本的颜色还存在)，这样就不会违反"特性(5)"。为什么呢？</span><br/>
<span style="color: rgb(0, 0, 0);">      通过RB-DELETE算法，我们知道：删除节点y之后，x占据了原来节点y的位置。 既然删除y(y是黑色)，意味着减少一个黑色节点；那么，再在该位置上增加一个黑色即可。这样，当我们假设"x包含一个额外的黑色"，就正好弥补了"删除 y所丢失的黑色节点"，也就不会违反"特性(5)"。 因此，假设"x包含一个额外的黑色"(x原本的颜色还存在)，这样就不会违反"特性(5)"。</span><br/>
<span style="color: rgb(0, 0, 0);">      现在，x不仅包含它原本的颜色属性，x还包含一个额外的黑色。即x的颜色属性是"红+黑"或"黑+黑"，它违反了"特性(1)"。</span></span></p>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">      现在，我们面临的问题，由解决"违反了特性(2)、(4)、(5)三个特性"转换成了"解决违反特性(1)、(2)、(4)三个特性"。RB- DELETE-FIXUP需要做的就是通过算法恢复红黑树的特性(1)、(2)、(4)。RB-DELETE-FIXUP的思想是：将x所包含的额外的黑 色不断沿树上移(向根方向移动)，直到出现下面的姿态：</span><br/>
<span style="color: rgb(0, 0, 0);">a) x指向一个"红+黑"节点。此时，将x设为一个"黑"节点即可。</span><br/>
<span style="color: rgb(0, 0, 0);">b) x指向根。此时，将x设为一个"黑"节点即可。</span><br/>
<span style="color: rgb(0, 0, 0);">c) 非前面两种姿态。</span></span></p>
</div>
<div><br/></div>
<div><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">将上面的姿态，可以概括为3种情况。（<span style="color: rgb(255, 38, 0);">黑红怎么办？答案：上面红色。红黑、黑红都染成黑色完事儿</span>）</span><br/>
<span style="color: rgb(0, 0, 0);">① 情况说明：x是“红+黑”节点。</span><br/>
<span style="color: rgb(0, 0, 0);">    处理方法：直接把x设为黑色，结束。此时红黑树性质全部恢复。</span><br/>
<span style="color: rgb(0, 0, 0);">② 情况说明：x是“黑+黑”节点，且x是根。</span><br/>
<span style="color: rgb(0, 0, 0);">    处理方法：什么都不做，结束。此时红黑树性质全部恢复。</span></span></div>
<div><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">③ 情况说明：x是“黑+黑”节点，且x不是根。</span></span></div>
<div><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">    处理方法：这种情况又可以划分为4种子情况。这4种子情况如下表所示：</span></span></div>
<div>
<table style="border-color: rgb(0, 0, 0); border-width: 0px; table-layout: fixed;width:48.210735586481114%;" border="0">
<tr style="background-color: #8b7483;">
<td style="width:4.948453608247423%;"><span style="font-size: 18px;"> </span></td>
<td style="width:67.5257731958763%;"><span style="font-size: 18px;"><strong><span style="color: rgb(0, 0, 0);">现象说明</span></strong></span></td>
<td style="width:27.010309278350515%;"><span style="font-size: 18px;"><strong><span style="color: rgb(0, 0, 0);">处理策略</span></strong></span></td>
</tr>
<tr>
<td style=""><span style="font-size: 18px;"><strong><span style="color: rgb(0, 0, 0);">Case 1</span></strong></span></td>
<td><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">x是"黑+黑"节点，x的兄弟节点是红色。(此时x的父节点和x的兄弟节点的子节点都是黑节点)。</span></span></td>
<td>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">(01) 将x的兄弟节点设为“黑色”。</span><br/>
<span style="color: rgb(0, 0, 0);">(02) 将x的父节点设为“红色”。</span><br/>
<span style="color: rgb(0, 0, 0);">(03) 对x的父节点进行左旋。</span><br/>
<span style="color: rgb(0, 0, 0);">(04) 左旋后，重新设置x的兄弟节点。</span></span></p>
</td>
</tr>
<tr>
<td><span style="font-size: 18px;"><strong><span style="color: rgb(0, 0, 0);">Case 2</span></strong></span></td>
<td><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">x是“黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色。</span></span></td>
<td>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">(01) 将x的兄弟节点设为“红色”。</span><br/>
<span style="color: rgb(0, 0, 0);">(02) 设置“x的父节点”为“新的x节点”。</span></span></p>
</td>
</tr>
<tr>
<td><span style="font-size: 18px;"><strong><span style="color: rgb(0, 0, 0);">Case 3</span></strong></span></td>
<td><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的。</span></span></td>
<td>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">(01) 将x兄弟节点的左孩子设为“黑色”。</span><br/>
<span style="color: rgb(0, 0, 0);">(02) 将x兄弟节点设为“红色”。</span><br/>
<span style="color: rgb(0, 0, 0);">(03) 对x的兄弟节点进行右旋。</span><br/>
<span style="color: rgb(0, 0, 0);">(04) 右旋后，重新设置x的兄弟节点。</span></span></p>
</td>
</tr>
<tr>
<td><span style="font-size: 18px;"><strong><span style="color: rgb(0, 0, 0);">Case 4</span></strong></span></td>
<td><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色。</span></span></td>
<td>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">(01) 将x父节点颜色 赋值给 x的兄弟节点。</span><br/>
<span style="color: rgb(0, 0, 0);">(02) 将x父节点设为“黑色”。</span><br/>
<span style="color: rgb(0, 0, 0);">(03) 将x兄弟节点的右子节设为“黑色”。</span><br/>
<span style="color: rgb(0, 0, 0);">(04) 对x的父节点进行左旋。</span><br/>
<span style="color: rgb(0, 0, 0);">(05) 设置“x”为“根节点”。</span></span></p>
</td>
</tr>
</table>
<p><span style="font-size: 18px;"> </span></p>
<p><span style="font-size: 18px;"><strong><span style="color: rgb(0, 0, 0);">1. (Case 1)x是"黑+黑"节点，x的兄弟节点是红色</span></strong></span></p>
<p><span style="font-size: 18px;"><strong><span style="color: rgb(0, 0, 0);">1.1 现象说明</span></strong><br/>
<span style="color: rgb(0, 0, 0);">x是"黑+黑"节点，x的兄弟节点是红色。(此时x的父节点和x的兄弟节点的子节点都是黑节点)。</span></span></p>
<p><span style="font-size: 18px;"><strong><span style="color: rgb(0, 0, 0);">1.2 处理策略</span></strong><br/>
<span style="color: rgb(0, 0, 0);">(01) 将x的兄弟节点设为“黑色”。</span><br/>
<span style="color: rgb(0, 0, 0);">(02) 将x的父节点设为“红色”。</span><br/>
<span style="color: rgb(0, 0, 0);">(03) 对x的父节点进行左旋。</span><br/>
<span style="color: rgb(0, 0, 0);">(04) 左旋后，重新设置x的兄弟节点。</span></span></p>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">      <strong>下面谈谈为什么要这样处理。</strong>(建议理解的时候，通过下面的图进行对比)</span><br/>
<span style="color: rgb(0, 0, 0);">      这样做的目的是将“Case 1”转换为“Case 2”、“Case 3”或“Case 4”，从而进行进一步的处理。对x的父节点进行左旋；左旋后，为了保持红黑树特性，就需要在左旋前“将x的兄弟节点设为黑色”，同时“将x的父节点设为红 色”；<span style="color: rgb(255, 38, 0);">左旋后，由于x的兄弟节点发生了变化，需要更新x的兄弟节点</span>，从而进行后续处理。</span></span></p>
<p><span style="font-size: 18px;"><strong><span style="color: rgb(0, 0, 0);">1.3 示意图</span></strong></span><span style="color: rgb(0, 0, 0);"><br/></span></p>
<p><span style="font-size: 18px;"><a href="http://images.cnitblog.com/i/497634/201403/251813539515702.jpg"><span style="color: rgb(0, 0, 0);"><img src="%E7%BA%A2%E9%BB%91%E6%A0%91(%E4%B8%80)%E4%B9%8B%20%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D.resources/D1C8E3DE-B98E-48CF-ADAE-83419112D3C5.jpg" height="316" width="1174"/></span></a></span></p>
<p><span style="font-size: 18px;"> </span></p>
<p><span style="font-size: 18px;"><strong><span style="color: rgb(0, 0, 0);">2. (Case 2) x是"黑+黑"节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色</span></strong></span></p>
<p><span style="font-size: 18px;"><strong><span style="color: rgb(0, 0, 0);">2.1 现象说明</span></strong><br/>
<span style="color: rgb(0, 0, 0);">x是“黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色。</span></span></p>
<p><span style="font-size: 18px;"><strong><span style="color: rgb(0, 0, 0);">2.2 处理策略</span></strong><br/>
<span style="color: rgb(0, 0, 0);">(01) 将x的兄弟节点设为“红色”。</span><br/>
<span style="color: rgb(0, 0, 0);">(02) 设置“x的父节点”为“新的x节点”。</span></span></p>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">      <strong>下面谈谈为什么要这样处理。</strong>(建议理解的时候，通过下面的图进行对比)</span><br/>
<span style="color: rgb(0, 0, 0);">      这个情况的处理思想：是将“x中多余的一个黑色属性上移(往根方向移动)”。 x是“黑+黑”节点，我们将x由“黑+黑”节点 变成 “黑”节点，多余的一个“黑”属性移到x的父节点中，即x的父节点多出了一个黑属性(若x的父节点原先是“黑”，则此时变成了“黑+黑”；若x的父节点原 先时“红”，则此时变成了“红+黑”)。 此时，需要注意的是：所有经过x的分支中黑节点个数没变化；但是，所有经过x的兄弟节点的分支中黑色节点的个数增加了1(因为x的父节点多了一个黑色属 性)！为了解决这个问题，我们需要将“所有经过x的兄弟节点的分支中黑色节点的个数减1”即可，那么就可以通过“将x的兄弟节点由黑色变成红色”来实现。</span><br/>
<span style="color: rgb(0, 0, 0);">      经过上面的步骤(将x的兄弟节点设为红色)，多余的一个颜色属性(黑色)已经跑到x的父节点中。我们需要将x的父节点设为“新的x节点”进行处理。若“新 的x节点”是“黑+红”，直接将“新的x节点”设为黑色，即可完全解决该问题；若“新的x节点”是“黑+黑”，则需要对“新的x节点”进行进一步处理。</span></span></p>
<p><span style="font-size: 18px;"><strong><span style="color: rgb(0, 0, 0);">2.3 示意图</span></strong></span><span style="color: rgb(0, 0, 0);"><br/></span></p>
<p><span style="font-size: 18px;"><a href="http://images.cnitblog.com/i/497634/201403/251814572322069.jpg"><strong><span style="color: rgb(0, 0, 0);"><img src="%E7%BA%A2%E9%BB%91%E6%A0%91(%E4%B8%80)%E4%B9%8B%20%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D.resources/1608C7FC-2FBE-4E8D-9446-BE42970F211B.jpg" height="323" width="1164"/></span></strong></a></span></p>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);"> </span></span></p>
<p><span style="font-size: 18px;"><strong><span style="color: rgb(0, 0, 0);">3. (Case 3)x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的</span></strong></span></p>
<p><span style="font-size: 18px;"><strong><span style="color: rgb(0, 0, 0);">3.1 现象说明</span></strong><br/>
<span style="color: rgb(0, 0, 0);">x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的。</span></span></p>
<p><span style="font-size: 18px;"><strong><span style="color: rgb(0, 0, 0);">3.2 处理策略</span></strong><br/>
<span style="color: rgb(0, 0, 0);">(01) 将x兄弟节点的左孩子设为“黑色”。</span><br/>
<span style="color: rgb(0, 0, 0);">(02) 将x兄弟节点设为“红色”。</span><br/>
<span style="color: rgb(0, 0, 0);">(03) 对x的兄弟节点进行右旋。</span><br/>
<span style="color: rgb(0, 0, 0);">(04) 右旋后，重新设置x的兄弟节点。</span></span></p>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">       <strong>下面谈谈为什么要这样处理。</strong>(建议理解的时候，通过下面的图进行对比)</span><br/>
<span style="color: rgb(0, 0, 0);">       我们处理“Case 3”的目的是为了将“Case 3”进行转换，转换成“Case 4”,从而进行进一步的处理。转换的方式是对x的兄弟节点进行右旋；为了保证右旋后，它仍然是红黑树，就需要在右旋前“将x的兄弟节点的左孩子设为黑 色”，同时“将x的兄弟节点设为红色”；右旋后，由于x的兄弟节点发生了变化，需要更新x的兄弟节点，从而进行后续处理。</span></span></p>
<p><span style="font-size: 18px;"><strong><span style="color: rgb(0, 0, 0);">3.3 示意图</span></strong></span></p>
<p><span style="font-size: 18px;"><a href="http://images.cnitblog.com/i/497634/201403/251815496235531.jpg"><strong><span style="color: rgb(0, 0, 0);"><img src="%E7%BA%A2%E9%BB%91%E6%A0%91(%E4%B8%80)%E4%B9%8B%20%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D.resources/71DB3387-9A28-4CA5-A510-18D208E824DF.jpg" height="406" width="1230"/></span></strong></a></span></p>
<p><span style="font-size: 18px;"> </span></p>
<p><span style="font-size: 18px;"><strong><span style="color: rgb(0, 0, 0);">4. (Case 4)x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色</span></strong></span></p>
<p><span style="font-size: 18px;"><strong><span style="color: rgb(0, 0, 0);">4.1 现象说明</span></strong><br/>
<span style="color: rgb(0, 0, 0);">x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色。</span></span></p>
<p><span style="font-size: 18px;"><strong><span style="color: rgb(0, 0, 0);">4.2 处理策略</span></strong><br/>
<span style="color: rgb(0, 0, 0);">(01) 将x父节点颜色 赋值给 x的兄弟节点。</span><br/>
<span style="color: rgb(0, 0, 0);">(02) 将x父节点设为“黑色”。</span><br/>
<span style="color: rgb(0, 0, 0);">(03) 将x兄弟节点的右子节设为“黑色”。</span><br/>
<span style="color: rgb(0, 0, 0);">(04) 对x的父节点进行左旋。</span><br/>
<span style="color: rgb(0, 0, 0);">(05) 设置“x”为“根节点”。</span></span></p>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">      <strong>下面谈谈为什么要这样处理。</strong>(建议理解的时候，通过下面的图进行对比)</span><br/>
<span style="color: rgb(0, 0, 0);">      我们处理“Case 4”的目的是：去掉x中额外的黑色，将x变成单独的黑色。处理的方式是“：进行颜色修改，然后对x的父节点进行左旋。下面，我们来分析是如何实现的。</span><br/>
<span style="color: rgb(0, 0, 0);">      为了便于说明，我们设置“当前节点”为S(Original Son)，“兄弟节点”为B(Brother)，“兄弟节点的左孩子”为BLS(Brother's Left Son)，“兄弟节点的右孩子”为BRS(Brother's Right Son)，“父节点”为F(Father)。</span><br/>
<span style="color: rgb(0, 0, 0);">      我们要对F进行左旋。但在左旋前，我们需要调换F和B的颜色，并设置BRS为黑色。为什么需要这里处理呢？因为左旋后，F和BLS是父子关系，而我们已知 BLS是红色，如果F是红色，则违背了“特性(4)”；为了解决这一问题，我们将“F设置为黑色”。 但是，F设置为黑色之后，为了保证满足“特性(5)”，即为了保证左旋之后：</span><br/>
<span style="color: rgb(0, 0, 0);">      第一，“同时经过根节点和S的分支的黑色节点个数不变”。</span><br/>
<span style="color: rgb(0, 0, 0);">             若满足“第一”，只需要S丢弃它多余的颜色即可。因为S的颜色是“黑+黑”，而左旋后“同时经过根节点和S的分支的黑色节点个数”增加了1；现在，只需将S由“黑+黑”变成单独的“黑”节点，即可满足“第一”。</span><br/>
<span style="color: rgb(0, 0, 0);">      第二，“同时经过根节点和BLS的分支的黑色节点数不变”。</span><br/>
<span style="color: rgb(0, 0, 0);">             若满足“第二”，只需要将“F的原始颜色”赋值给B即可。之前，我们已经将“F设置为黑色”(即，将B的颜色"黑色"，赋值给了F)。至此，我们算是调换了F和B的颜色。</span><br/>
<span style="color: rgb(0, 0, 0);">      第三，“同时经过根节点和BRS的分支的黑色节点数不变”。</span><br/>
<span style="color: rgb(0, 0, 0);">             在“第二”已经满足的情况下，若要满足“第三”，只需要将BRS设置为“黑色”即可。</span><br/>
<span style="color: rgb(0, 0, 0);">经过，上面的处理之后。红黑树的特性全部得到的满足！接着，我们将x设为根节点，就可以跳出while循环(参考伪代码)；即完成了全部处理。</span></span></p>
<p><span style="font-size: 18px;"><span style="color: rgb(0, 0, 0);">至此，我们就完成了Case 4的处理。理解Case 4的核心，是了解如何“去掉当前节点额外的黑色”。</span></span></p>
<p><span style="font-size: 18px;"><strong><span style="color: rgb(0, 0, 0);">4.3 示意图</span></strong></span></p>
<p><span style="font-size: 18px;"><a href="http://images.cnitblog.com/i/497634/201403/251817189983393.jpg"><img src="%E7%BA%A2%E9%BB%91%E6%A0%91(%E4%B8%80)%E4%B9%8B%20%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D.resources/A002525B-2E7C-4099-A51F-7BDBF6F5AB5D.jpg" height="323" width="1117"/></a></span></p>
<p><span style="font-size: 18px;"><span style="color: rgb(255, 0, 0);">   </span></span></p>
<p><span style="font-size: 18px;"><span style="color: rgb(255, 0, 0);">OK！至此，红黑树的理论知识差不多讲完了。后续再更新红黑树的实现代码！</span></span></p>
<hr/>
<h1><span style="font-size: 18px;"><span style="color: #ff0000;">参考文献</span></span></h1>
<p><span style="font-size: 18px;">1, 《算法导论》</span></p>
<p><span style="font-size: 18px;">2,  <a href="http://blog.csdn.net/v_JULY_v/article/details/6105630">教你透彻了解红黑树</a></span></p>
<p><span style="font-size: 18px;"> </span></p>
</div>
<div>
<div style="">
<table style="width:1032px;">
<tr>
<td style="width:10.852713178294573%;"><span style="font-size: 18px;"><img src="%E7%BA%A2%E9%BB%91%E6%A0%91(%E4%B8%80)%E4%B9%8B%20%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D.resources/8A02D1AA-F977-4630-A851-8B472D81AF9F.jpg" height="120" width="109"/></span></td>
<td style="font-weight: normal; font-style: normal; font-variant-ligatures: normal; font-variant-position: normal; font-variant-caps: normal; font-variant-numeric: normal; font-variant-alternates: normal; font-variant-east-asian: normal; color: rgb(255, 0, 0);width:88.75968992248062%;"><span style="font-size: 18px;"><font style="color: rgb(97, 11, 33);">生活的悲欢离合永远在地平线以外，而眺望是一种青春的姿态...</font><br/>
PS.文章是笔者分享的学习笔记，若你觉得可以、还行、过得去、甚至不太差的话，可以“推荐”一下的哦。就此谢过!</span></td>
</tr>
</table>
</div>
<div>
<div><span style="font-size: 18px;">分类: <a target="_blank" href="http://www.cnblogs.com/skywang12345/category/508186.html">数据结构_算法</a></span></div>
<div><span style="font-size: 18px;">标签: <a href="http://www.cnblogs.com/skywang12345/tag/%E8%AF%A6%E8%A7%A3/">详解</a>, <a href="http://www.cnblogs.com/skywang12345/tag/%E7%BA%A2%E9%BB%91%E6%A0%91/">红黑树</a>, <a href="http://www.cnblogs.com/skywang12345/tag/%E5%B7%A6%E6%97%8B/">左旋</a>, <a href="http://www.cnblogs.com/skywang12345/tag/%E5%8F%B3%E6%97%8B/">右旋</a>, <a href="http://www.cnblogs.com/skywang12345/tag/AVL%E6%A0%91/">AVL树</a>, <a href="http://www.cnblogs.com/skywang12345/tag/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/">时间复杂度</a>, <a href="http://www.cnblogs.com/skywang12345/tag/%E6%8F%92%E5%85%A5/">插入</a>, <a href="http://www.cnblogs.com/skywang12345/tag/%E5%88%A0%E9%99%A4/">删除</a>, <a href="http://www.cnblogs.com/skywang12345/tag/R%20B%20Tree/">R B Tree</a></span></div>
<div>
<div><span style="font-size: 18px;"><a name="green_channel_digg">好文要顶</a> <a name="green_channel_follow">关注我</a> <a name="green_channel_favorite">收藏该文</a> <a name="green_channel_weibo" title="分享至新浪微博"><img src="%E7%BA%A2%E9%BB%91%E6%A0%91(%E4%B8%80)%E4%B9%8B%20%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D.resources/E9EA4AAE-8D3A-4E8B-981A-DCD6DCA0E1E1.png" height="24" width="24"/></a> <a name="green_channel_wechat" title="分享至微信"><img src="%E7%BA%A2%E9%BB%91%E6%A0%91(%E4%B8%80)%E4%B9%8B%20%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D.resources/79276441-DDBE-44DC-A66C-2C9C1EDB241B.png" height="48" width="48"/></a></span></div>
<div>
<div><span style="font-size: 18px;"><a target="_blank" href="http://home.cnblogs.com/u/skywang12345/"><img src="%E7%BA%A2%E9%BB%91%E6%A0%91(%E4%B8%80)%E4%B9%8B%20%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D.resources/7CB7CC3F-45D8-430A-8A56-BDD9F7D93D9A.jpg" height="48" width="48"/></a></span>
<div><span style="font-size: 18px;"><a href="http://home.cnblogs.com/u/skywang12345/">如果天空不死</a><br/>
<a href="http://home.cnblogs.com/u/skywang12345/followees">关注 - 9</a><br/>
<a href="http://home.cnblogs.com/u/skywang12345/followers">粉丝 - 1109</a></span></div>
</div>
<div><span style="font-size: 18px;"><a>+加关注</a></span></div>
</div>
<div>
<div><span style="font-size: 18px;">32</span></div>
<div><span style="font-size: 18px;">0</span></div>
</div>
</div>
<div><span style="font-size: 18px;"><a href="http://www.cnblogs.com/skywang12345/p/3165544.html">«</a> 上一篇：<a title="发布于2013-07-03 15:38" href="http://www.cnblogs.com/skywang12345/p/3165544.html">Android Service总结06 之AIDL</a><br/>
<a href="http://www.cnblogs.com/skywang12345/p/3263724.html">»</a> 下一篇：<a title="发布于2013-08-17 00:00" href="http://www.cnblogs.com/skywang12345/p/3263724.html">Android控件之GridView</a></span></div>
</div>
</div>
<div>
<div><span style="font-size: 18px;">posted on 2013-08-13 22:59 <a href="http://www.cnblogs.com/skywang12345/">如果天空不死</a> 阅读(38995) 评论(30) <a rel="nofollow" href="https://i.cnblogs.com/EditPosts.aspx?postid=3245399">编辑</a> <a href="http://www.cnblogs.com/skywang12345/p/3245399.html#">收藏</a></span></div>
</div>
<div>
<div>
<div><span style="font-size: 18px;">Comments</span></div>
</div>
<ul>
<li><span style="font-size: 18px;"><a href="http://www.cnblogs.com/skywang12345/p/3245399.html#2750553">#1楼</a><a name="2750553"/><br/>
<a target="_blank" href="http://www.cnblogs.com/lidayu-wp/" name="a_comment_author_2750553">深蓝wp</a> <a title="发送站内短消息" href="http://msg.cnblogs.com/send/%E6%B7%B1%E8%93%9Dwp"> </a><br/>
Posted @ 2013-08-13 23:43<br/>
这算法高级啊，提到的东西比较前沿呢<br/>
<a>支持(0)</a><a>反对(0)</a><br/>
  </span></li>
<li><span style="font-size: 18px;"><a href="http://www.cnblogs.com/skywang12345/p/3245399.html#2750691">#2楼</a><a name="2750691"/><br/>
<a target="_blank" href="http://www.cnblogs.com/yjiyjige/" name="a_comment_author_2750691">孤~影</a> <a title="发送站内短消息" href="http://msg.cnblogs.com/send/%E5%AD%A4%7E%E5%BD%B1"> </a><br/>
Posted @ 2013-08-14 09:13<br/>
这个绝对要支持！！！<br/>
正好学习一下。<br/>
请问这些图片是用什么软件画出来的？<br/>
<a>支持(0)</a><a>反对(0)</a><br/>
  </span></li>
<li><span style="font-size: 18px;"><a href="http://www.cnblogs.com/skywang12345/p/3245399.html#2751399">#3楼</a><a name="2751399"/>[楼主]<br/>
<a target="_blank" href="http://www.cnblogs.com/skywang12345/" name="a_comment_author_2751399">如果天空不死</a> <a title="发送站内短消息" href="http://msg.cnblogs.com/send/%E5%A6%82%E6%9E%9C%E5%A4%A9%E7%A9%BA%E4%B8%8D%E6%AD%BB"> </a><br/>
Posted @ 2013-08-14 18:48<br/>
<a title="查看所回复的评论" href="http://www.cnblogs.com/skywang12345/p/3245399.html#2750691">@</a> 孤~影<br/>
图片不是我自己画的，是引用其它地方的。<br/>
至于作图软件，windows 下面的我习惯用 Microsoft Visio；在ubuntu 下面我习惯使用DIA。<br/>
<a>支持(0)</a><a>反对(0)</a><br/>
  </span></li>
<li><span style="font-size: 18px;"><a href="http://www.cnblogs.com/skywang12345/p/3245399.html#2773402">#4楼</a><a name="2773402"/><br/>
<a target="_blank" href="http://home.cnblogs.com/u/566921/" name="a_comment_author_2773402">wkhuang</a> <a title="发送站内短消息" href="http://msg.cnblogs.com/send/wkhuang"> </a><br/>
Posted @ 2013-09-11 16:03<br/>
你好~可以加一下我的QQ么，我QQ是619924634，想问问有关红黑树的删除的问题，谢谢！<br/>
<a>支持(0)</a><a>反对(1)</a><br/>
  </span></li>
<li><span style="font-size: 18px;"><a href="http://www.cnblogs.com/skywang12345/p/3245399.html#2781502">#5楼</a><a name="2781502"/><br/>
<a target="_blank" href="http://www.cnblogs.com/zhengyuhong/" name="a_comment_author_2781502">林羽飞扬</a> <a title="发送站内短消息" href="http://msg.cnblogs.com/send/%E6%9E%97%E7%BE%BD%E9%A3%9E%E6%89%AC"> </a><br/>
Posted @ 2013-09-24 22:59<br/>
哇塞，写得很好。想问问博主用什么绘图的啊，这么细腻<br/>
<a>支持(0)</a><a>反对(0)</a><br/>
  </span></li>
<li><span style="font-size: 18px;"><a href="http://www.cnblogs.com/skywang12345/p/3245399.html#2868612">#6楼</a><a name="2868612"/><br/>
<a target="_blank" href="http://home.cnblogs.com/u/317378/" name="a_comment_author_2868612">liudegui</a> <a title="发送站内短消息" href="http://msg.cnblogs.com/send/liudegui"> </a><br/>
Posted @ 2014-01-26 16:18<br/>
“由红黑树的特性(4)’可知 bh(x)&gt;=h/2”。这句话没有看懂，这是怎么得出的？<br/>
<a>支持(0)</a><a>反对(0)</a><br/>
  </span></li>
<li><span style="font-size: 18px;"><a href="http://www.cnblogs.com/skywang12345/p/3245399.html#2868615">#7楼</a><a name="2868615"/><br/>
<a target="_blank" href="http://home.cnblogs.com/u/317378/" name="a_comment_author_2868615">liudegui</a> <a title="发送站内短消息" href="http://msg.cnblogs.com/send/liudegui"> </a><br/>
Posted @ 2014-01-26 16:20<br/>
文中<br/>
"一棵含有n个节点的红黑树的高度至多为2log(n+1)" 的逆否命题是 "高度为h的红黑树，它的包含的内节点个数至少为 2^{h/2}-1个"<br/>
和它的下面隔四行的一句，<br/>
"高度为h的红黑树，它的包含的内节点个数至少为 2^bh(x)-1个"。<br/>
无缘五故多了个b，实在搞不懂b是怎么加上去的？<br/>
<a>支持(0)</a><a>反对(0)</a><br/>
  </span></li>
<li><span style="font-size: 18px;"><a href="http://www.cnblogs.com/skywang12345/p/3245399.html#2868699">#8楼</a><a name="2868699"/>[楼主]<br/>
<a target="_blank" href="http://www.cnblogs.com/skywang12345/" name="a_comment_author_2868699">如果天空不死</a> <a title="发送站内短消息" href="http://msg.cnblogs.com/send/%E5%A6%82%E6%9E%9C%E5%A4%A9%E7%A9%BA%E4%B8%8D%E6%AD%BB"> </a><br/>
Posted @ 2014-01-26 17:46<br/>
<a title="查看所回复的评论" href="http://www.cnblogs.com/skywang12345/p/3245399.html#2868612">@</a> liudegui<br/>
根据红黑色的"特性(4)，即如果一个节点是红色的，则它的子节点必须是黑色的"可知，从节点x出发达到叶节点"所经历的黑节点数目"&gt;= "所经历的红节点的数目"。假设x是根节点，则可以得出结论"bh(x) &gt;= h/2"。<br/>
关于这一点，我已经修改了原文，对此进行了补充说明。<br/>
<a>支持(0)</a><a>反对(0)</a><br/>
  </span></li>
<li><span style="font-size: 18px;"><a href="http://www.cnblogs.com/skywang12345/p/3245399.html#2868701">#9楼</a><a name="2868701"/>[楼主]<br/>
<a target="_blank" href="http://www.cnblogs.com/skywang12345/" name="a_comment_author_2868701">如果天空不死</a> <a title="发送站内短消息" href="http://msg.cnblogs.com/send/%E5%A6%82%E6%9E%9C%E5%A4%A9%E7%A9%BA%E4%B8%8D%E6%AD%BB"> </a><br/>
Posted @ 2014-01-26 17:47<br/>
<a title="查看所回复的评论" href="http://www.cnblogs.com/skywang12345/p/3245399.html#2868615">@</a> liudegui<br/>
原文中对bh(x)的定义有进行介绍。<br/>
bh(x)的定义：从某个节点x出发（不包括该节点）到达一个叶节点的任意一条路径上，黑色节点的个数称为该节点的黑高度(x's black height)。<br/>
<a>支持(0)</a><a>反对(0)</a><br/>
  </span></li>
<li><span style="font-size: 18px;"><a href="http://www.cnblogs.com/skywang12345/p/3245399.html#2909507">#10楼</a><a name="2909507"/><br/>
<a target="_blank" href="http://www.cnblogs.com/cangling20041616/" name="a_comment_author_2909507">以我之丿名</a> <a title="发送站内短消息" href="http://msg.cnblogs.com/send/%E4%BB%A5%E6%88%91%E4%B9%8B%E4%B8%BF%E5%90%8D"> </a><br/>
Posted @ 2014-04-02 09:56<br/>
。。。最近在学习算法，刚刚研究到红黑树哪里。。每天晚上理解一遍，已经一周多了，插入，删除记住了是记住了，可是自己总是推不出来，有可能过两三周又忘了。。哎。。。。。。。。。。。！！！！！！！！<br/>
<a>支持(1)</a><a>反对(0)</a><br/>
  </span></li>
<li><span style="font-size: 18px;"><a href="http://www.cnblogs.com/skywang12345/p/3245399.html#2919248">#11楼</a><a name="2919248"/><br/>
<a target="_blank" href="http://home.cnblogs.com/u/239512/" name="a_comment_author_2919248">xuezhimeng</a> <a title="发送站内短消息" href="http://msg.cnblogs.com/send/xuezhimeng"> </a><br/>
Posted @ 2014-04-16 16:00<br/>
很好的文章，非常详细。<br/>
<br/>
添加操作里的<br/>
2.3 示意图<br/>
这个不对吧，80那个节点的不见了。<br/>
<a>支持(0)</a><a>反对(0)</a><br/>
  </span></li>
<li><span style="font-size: 18px;"><a href="http://www.cnblogs.com/skywang12345/p/3245399.html#2919677">#12楼</a><a name="2919677"/>[楼主]<br/>
<a target="_blank" href="http://www.cnblogs.com/skywang12345/" name="a_comment_author_2919677">如果天空不死</a> <a title="发送站内短消息" href="http://msg.cnblogs.com/send/%E5%A6%82%E6%9E%9C%E5%A4%A9%E7%A9%BA%E4%B8%8D%E6%AD%BB"> </a><br/>
Posted @ 2014-04-17 09:49<br/>
<a title="查看所回复的评论" href="http://www.cnblogs.com/skywang12345/p/3245399.html#2919248">@</a> xuezhimeng<br/>
嗯，谢谢指出。原文已修正。<br/>
<a>支持(0)</a><a>反对(0)</a><br/>
  </span></li>
<li><span style="font-size: 18px;"><a href="http://www.cnblogs.com/skywang12345/p/3245399.html#2940549">#13楼</a><a name="2940549"/><br/>
<a target="_blank" href="http://www.cnblogs.com/omycle/" name="a_comment_author_2940549">omycle</a> <a title="发送站内短消息" href="http://msg.cnblogs.com/send/omycle"> </a><br/>
Posted @ 2014-05-16 17:37<br/>
删除的1.3示意图是错的。处理完后，B D 颜色没有互换。<br/>
<br/>
删除的case 4."x的兄弟节点的左孩子任意颜色"，而在原因中“因为左旋后，F和BLS是父子关系，而<b>我们已知BL是红色</b>，如果F是红色，则违背了“特性(4)”“<br/>
矛盾了。<br/>
<a>支持(2)</a><a>反对(0)</a><br/>
  </span></li>
<li><span style="font-size: 18px;"><a href="http://www.cnblogs.com/skywang12345/p/3245399.html#2965882">#14楼</a><a name="2965882"/><br/>
<a target="_blank" href="http://www.cnblogs.com/xiangnan/" name="a_comment_author_2965882">LisPythoniC</a> <a title="发送站内短消息" href="http://msg.cnblogs.com/send/LisPythoniC"> </a><br/>
Posted @ 2014-06-17 11:40<br/>
图2.2和2.3的120节点的颜色应该是黑色.因为它是叔叔节点.<br/>
<a>支持(3)</a><a>反对(0)</a><br/>
  </span></li>
<li><span style="font-size: 18px;"><a href="http://www.cnblogs.com/skywang12345/p/3245399.html#2989624">#15楼</a><a name="2989624"/><br/>
<a target="_blank" href="http://home.cnblogs.com/u/652023/" name="a_comment_author_2989624">Rainicy</a> <a title="发送站内短消息" href="http://msg.cnblogs.com/send/Rainicy"> </a><br/>
Posted @ 2014-07-18 12:24<br/>
感谢楼主写的很详细呢。但是总觉得在Insertion操作中对Case 2的处理策略进行解释的有点片面。<br/>
之所以要左旋和将父节点作为当前节点，其实根本原因不是红黑树的核心思想，这里体现的不是核心思想。对整个算法来说遵从了核心思想，而这里左旋只是为了到达Case 3的效果，为Case 3的右旋做准备，为什么这么说呢？<br/>
我认为在Case 1中，如果叔叔是红节点，我们可以只通过color changes操作，避免性质4和5的冲突，因为此时我们可以调节叔叔的颜色为黑色，来保证叔叔path上黑色节点数增加，从而平衡。<br/>
<br/>
而 在Case 2中，只通过color changes操作没法保证避免性质4、5. 这时候我们只能迫于无赖采用旋转操作。因为此时父亲节点是祖父节点的左孩子，所以我们猜测可能要对祖父节点旋转选择右旋转。（如果假设我们跳过Case2 的操作，直接进行Case 3的操作），也就是此时当前节点依然是父亲节点的右孩子，我们首先采用case3 的第一步操作，变父亲节点为黑色，消除了性质4，但是此时父亲所在路径多了一个黑节点，我们想把父亲往上一层，然后把祖父变为红色右侧下一层，也就是所谓 的对祖父进行右旋转。 注意到，祖父此时变为红色，而且父节点的右孩子也就是当前节点（红色）要变成祖父节点的左孩子。那么变化后，祖父节点和当前节点在相邻的两层了，而且同时 为红色。又带来了冲突。 最简单的方法就是在右旋转的前，把当前节点红色转移到左孩子去。这就是Case 2 为什么要这么做的原因了。<br/>
<br/>
感觉说了一大堆，还是说的不怎么清楚，但其实楼主只要在case 2的情况下，跳过case 2的操作，直接进行case 3，画画图，就知道为什么了～<br/>
<a>支持(0)</a><a>反对(0)</a><br/>
  </span></li>
<li><span style="font-size: 18px;"><a href="http://www.cnblogs.com/skywang12345/p/3245399.html#2995191">#16楼</a><a name="2995191"/><br/>
<a target="_blank" href="http://www.cnblogs.com/cronaldo/" name="a_comment_author_2995191">ramboww</a> <a title="发送站内短消息" href="http://msg.cnblogs.com/send/ramboww"> </a><br/>
Posted @ 2014-07-26 21:12<br/>
图画错了，叔节点是黑色的。<br/>
<a>支持(1)</a><a>反对(0)</a><br/>
  </span></li>
<li><span style="font-size: 18px;"><a href="http://www.cnblogs.com/skywang12345/p/3245399.html#3010311">#17楼</a><a name="3010311"/><br/>
<a target="_blank" href="http://www.cnblogs.com/cronaldo/" name="a_comment_author_3010311">ramboww</a> <a title="发送站内短消息" href="http://msg.cnblogs.com/send/ramboww"> </a><br/>
Posted @ 2014-08-18 20:40<br/>
大赞，讲解的非常到位！<br/>
<a>支持(0)</a><a>反对(0)</a><br/>
  </span></li>
<li><span style="font-size: 18px;"><a href="http://www.cnblogs.com/skywang12345/p/3245399.html#3010331">#18楼</a><a name="3010331"/><br/>
<a target="_blank" href="http://www.cnblogs.com/cronaldo/" name="a_comment_author_3010331">ramboww</a> <a title="发送站内短消息" href="http://msg.cnblogs.com/send/ramboww"> </a><br/>
Posted @ 2014-08-18 21:17<br/>
被删除节点没有儿子，即为叶节点。那么，直接将该节点删除就OK了。那么这种情况算在下面那个case里？<br/>
<a>支持(0)</a><a>反对(0)</a><br/>
  </span></li>
<li><span style="font-size: 18px;"><a href="http://www.cnblogs.com/skywang12345/p/3245399.html#3130745">#19楼</a><a name="3130745"/><br/>
<a target="_blank" href="http://www.cnblogs.com/encode/" name="a_comment_author_3130745">放作夥</a> <a title="发送站内短消息" href="http://msg.cnblogs.com/send/%E6%94%BE%E4%BD%9C%E5%A4%A5"> </a><br/>
Posted @ 2015-02-22 11:55<br/>
很佩服楼主整理了数据结构，但是伪码的缩进如果能完善就更好了<br/>
<a>支持(0)</a><a>反对(0)</a><br/>
  </span></li>
<li><span style="font-size: 18px;"><a href="http://www.cnblogs.com/skywang12345/p/3245399.html#3204867">#20楼</a><a name="3204867"/><br/>
<a target="_blank" href="http://www.cnblogs.com/suyuan1573/" name="a_comment_author_3204867">东京下雨，淋湿巴黎</a> <a title="发送站内短消息" href="http://msg.cnblogs.com/send/%E4%B8%9C%E4%BA%AC%E4%B8%8B%E9%9B%A8%EF%BC%8C%E6%B7%8B%E6%B9%BF%E5%B7%B4%E9%BB%8E"> </a><br/>
Posted @ 2015-06-09 22:05<br/>
图画的稍微有点问题，节点插入前就不是红黑树<br/>
<a>支持(0)</a><a>反对(0)</a><br/>
  </span></li>
<li><span style="font-size: 18px;"><a href="http://www.cnblogs.com/skywang12345/p/3245399.html#3351904">#21楼</a><a name="3351904"/><br/>
<a target="_blank" href="http://www.cnblogs.com/bbvi/" name="a_comment_author_3351904">拉拉叟</a> <a title="发送站内短消息" href="http://msg.cnblogs.com/send/%E6%8B%89%E6%8B%89%E5%8F%9F"> </a><br/>
Posted @ 2016-01-21 15:56<br/>
通过在你的博客学习， 尝试实现了个javascript版本。<br/>
可以在线演示：<br/>
<a target="_blank" href="http://sandbox.runjs.cn/show/2nngvn8w">http://sandbox.runjs.cn/show/2nngvn8w</a><br/>
<a>支持(3)</a><a>反对(0)</a><br/>
  </span></li>
<li><span style="font-size: 18px;"><a href="http://www.cnblogs.com/skywang12345/p/3245399.html#3370074">#22楼</a><a name="3370074"/><br/>
<a target="_blank" href="http://www.cnblogs.com/huangjuegeek/" name="a_comment_author_3370074">huangjuegeek</a> <a title="发送站内短消息" href="http://msg.cnblogs.com/send/huangjuegeek"> </a><br/>
Posted @ 2016-03-02 10:50<br/>
右旋第一张图下面那句话应该是<br/>
对y进行左旋，意味着"将y变成一个右节点"吧<br/>
<a>支持(0)</a><a>反对(0)</a><br/>
  </span></li>
<li><span style="font-size: 18px;"><a href="http://www.cnblogs.com/skywang12345/p/3245399.html#3425397">#23楼</a><a name="3425397"/><br/>
<a target="_blank" href="http://www.cnblogs.com/kemivong/" name="a_comment_author_3425397">NimbusK</a> <a title="发送站内短消息" href="http://msg.cnblogs.com/send/NimbusK"> </a><br/>
Posted @ 2016-05-08 10:17<br/>
示意图1.3及其后面有问题的。<br/>
经过case1转化后，当前结点是60，60的叔节点是红色，60叔节点是120，不对呐。<br/>
120改成黑色，140改成红色，后面的都能说的通，<b>自然也没有博主说的最后一句“提示：上面的进行Case 3处理之后，再将节点"120"当作当前节点，就变成了Case 2的情况。”</b>，我随手改了一下颜色，诸位对比一下便是。<br/>
<img src="%E7%BA%A2%E9%BB%91%E6%A0%91(%E4%B8%80)%E4%B9%8B%20%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D.resources/5B869CA4-4E24-4923-8B47-8A9E6A8570D1.png" height="522" width="1608"/><br/>
<img src="%E7%BA%A2%E9%BB%91%E6%A0%91(%E4%B8%80)%E4%B9%8B%20%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D.resources/F4C7F96B-5AE1-4FB4-BEB1-04E1EE081153.png" height="507" width="1665"/><br/>
<img src="%E7%BA%A2%E9%BB%91%E6%A0%91(%E4%B8%80)%E4%B9%8B%20%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D.resources/7F9AE67A-AA6B-430D-9989-608DAF3B979F.png" height="506" width="1664"/><br/>
<a>支持(4)</a><a>反对(0)</a><br/>
  </span></li>
<li><span style="font-size: 18px;"><br/>
case1<br/>
是为了一层一层向上递归 递归到根节点 直接黑掉根节点的红色<br/>
<br/>
case2<br/>
这种情况不好处理，或者说仅仅为了从左到右的习惯，把这个棘手的右孩 子转为左孩子处理（可以这么理解、虽然这样不对）这样的结果就是变成了case3<br/>
<br/>
case3<br/>
默认添加之前该树就是红黑树，这么一处理就对了，不需要再处理。循环到此结束！<br/>
<br/>
综上所述针对添加操作怎么复原红黑树？<br/>
第一种情况：递归到根节点、直接黑掉根节点<br/>
第二种情况：这种情况不处理，直接转成第三种情况<br/>
第三种情况：一次到位。<br/>
<a>支持(0)</a><a>反对(0)</a><br/>
  </span></li>
<li><span style="font-size: 18px;"><a href="http://www.cnblogs.com/skywang12345/p/3245399.html#3583400">#26楼</a><a name="3583400"/><br/>
<a target="_blank" href="http://www.cnblogs.com/BiuBiuBong/" name="a_comment_author_3583400">BiuBiuBong</a> <a title="发送站内短消息" href="http://msg.cnblogs.com/send/BiuBiuBong"> </a><br/>
Posted @ 2016-12-17 16:08<br/>
<a title="查看所回复的评论" href="http://www.cnblogs.com/skywang12345/p/3245399.html#3351904">@</a> 拉拉叟<br/>
禽兽啊 好厉害 膜拜<br/>
<a>支持(0)</a><a>反对(0)</a><br/>
  </span></li>
<li><span style="font-size: 18px;"><a href="http://www.cnblogs.com/skywang12345/p/3245399.html#3583410">#27楼</a><a name="3583410"/><br/>
<a target="_blank" href="http://www.cnblogs.com/BiuBiuBong/" name="a_comment_author_3583410">BiuBiuBong</a> <a title="发送站内短消息" href="http://msg.cnblogs.com/send/BiuBiuBong"> </a><br/>
Posted @ 2016-12-17 16:18<br/>
<a title="查看所回复的评论" href="http://www.cnblogs.com/skywang12345/p/3245399.html#3425397">@</a> NimbusK<br/>
图画的很对<br/>
我现在看到的博文图已经很正确<br/>
顺便提示：当前节点是表字母c的节点<br/>
<a>支持(0)</a><a>反对(0)</a><br/>
  </span></li>
<li><span style="font-size: 18px;"><a href="http://www.cnblogs.com/skywang12345/p/3245399.html#3583465">#28楼</a><a name="3583465"/><br/>
<a target="_blank" href="http://www.cnblogs.com/BiuBiuBong/" name="a_comment_author_3583465">BiuBiuBong</a> <a title="发送站内短消息" href="http://msg.cnblogs.com/send/BiuBiuBong"> </a><br/>
Posted @ 2016-12-17 19:38<br/>
博主您好<br/>
删除之后的红黑树恢复太难看懂了<br/>
怎么办<br/>
路过的有没有什么好方法<br/>
<a>支持(0)</a><a>反对(0)</a><br/>
  </span></li>
<li><span style="font-size: 18px;"><a href="http://www.cnblogs.com/skywang12345/p/3245399.html#3595905">#29楼</a><a name="3595905"/><br/>
<a target="_blank" href="http://home.cnblogs.com/u/1090602/" name="a_comment_author_3595905">youkobak</a> <a title="发送站内短消息" href="http://msg.cnblogs.com/send/youkobak"> </a><br/>
Posted @ 2017-01-04 11:16<br/>
<a title="查看所回复的评论" href="http://www.cnblogs.com/skywang12345/p/3245399.html#3425397">@</a> NimbusK<br/>
确实博主case2开始的处理就是错的，然后我跟着博主一路错下来到case3，当前节点从40突然变成120了不明所以。。。谢谢大神<br/>
<a>支持(0)</a><a>反对(0)</a><br/>
  </span></li>
<li><span style="font-size: 18px;"><a href="http://www.cnblogs.com/skywang12345/p/3245399.html#3604166">#30楼</a><a name="3604166"/><br/>
<a target="_blank" href="http://www.cnblogs.com/zhengbin/" name="a_comment_author_3604166">郑州的文武</a> <a title="发送站内短消息" href="http://msg.cnblogs.com/send/%E9%83%91%E5%B7%9E%E7%9A%84%E6%96%87%E6%AD%A6"> </a><br/>
Posted @ 2017-01-16 10:38<br/>
<a title="查看所回复的评论" href="http://www.cnblogs.com/skywang12345/p/3245399.html#3351904">@</a> 拉拉叟<br/>
赞！！<br/>
<a>支持(1)</a><a>反对(0)</a><br/>
  </span></li>
</ul>
<div>
<div><a name="commentform"/>
<div><span style="font-size: 18px;"><a name="lnk_RefreshComments">刷新评论</a><a href="http://www.cnblogs.com/skywang12345/p/3245399.html#">刷新页面</a><a href="http://www.cnblogs.com/skywang12345/p/3245399.html#top">返回顶部</a></span></div>
<div>
<div><span style="font-size: 18px;">注册用户登录后才能发表评论，请 <a rel="nofollow">登录</a> 或 <a rel="nofollow">注册</a>，<a href="http://www.cnblogs.com">访问</a>网站首页。</span></div>
</div>
<div><span style="font-size: 18px;"><a target="_blank" href="http://www.ucancode.com/index.htm">【推荐】50万行VC++源码: 大型组态工控、电力仿真CAD与GIS源码库</a><br/>
<a target="_blank" href="http://www.gcpowertools.com.cn/products/activereports_casestudies.htm?utm_source=cnblogs&amp;utm_medium=blogpage&amp;utm_term=bottom&amp;utm_content=AR&amp;utm_campaign=community">【推荐】中铁、中石油等大型企业的复杂报表解决方案</a><br/>
<a target="_blank" href="https://group.cnblogs.com/topic/76725.html">【福利】阿里云免费套餐升级，更多产品，更久时长</a></span></div>
<div><span style="font-size: 18px;"><a target="_blank" href="https://cn.udacity.com/course/machine-learning-engineer-nanodegree--nd009-cn-basic/?utm_source=cnblogs&amp;utm_medium=referral&amp;utm_campaign=MLND02"><img src="%E7%BA%A2%E9%BB%91%E6%A0%91(%E4%B8%80)%E4%B9%8B%20%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D.resources/0F148AF3-FE36-4B6A-99B2-B9B7B09E21E9.jpg" height="1333" width="1600"/></a></span></div>
<div>
<div><span style="font-size: 18px;"><b>最新IT新闻</b>:<br/>
· <a target="_blank" href="http://news.cnblogs.com/n/568328/">小米官方回应与万科合作建房被叫停：没听说建房事宜</a><br/>
· <a target="_blank" href="http://news.cnblogs.com/n/568327/">锤子发布会邀请函曝光：好简单</a><br/>
· <a target="_blank" href="http://news.cnblogs.com/n/568326/">微软B站投放Lumia手机广告合集：与Lumia做最后告别</a><br/>
· <a target="_blank" href="http://news.cnblogs.com/n/568325/">微软注册新专利 将让DirectX 12的游戏体验更爽！</a><br/>
· <a target="_blank" href="http://news.cnblogs.com/n/568324/">任正非：华为总部不会离开深圳</a><br/>
» <a target="_blank" href="http://news.cnblogs.com/" title="IT新闻">更多新闻...</a></span></div>
</div>
<div><span style="font-size: 18px;"><a target="_blank" href="http://click.aliyun.com/m/15483/"><img src="%E7%BA%A2%E9%BB%91%E6%A0%91(%E4%B8%80)%E4%B9%8B%20%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D.resources/F0844DD4-43DB-48B1-A6FD-5CA83CB3F587.jpg" height="120" width="936"/></a></span></div>
<div>
<div><span style="font-size: 18px;"><b>最新知识库文章</b>:</span>
<div><span style="font-size: 18px;">· <a target="_blank" href="http://kb.cnblogs.com/page/565901/">唱吧DevOps的落地，微服务CI/CD的范本技术解读</a><br/>
· <a target="_blank" href="http://kb.cnblogs.com/page/566523/">程序员，如何从平庸走向理想？</a><br/>
· <a target="_blank" href="http://kb.cnblogs.com/page/566318/">我为什么鼓励工程师写blog</a><br/>
· <a target="_blank" href="http://kb.cnblogs.com/page/566528/">怎么轻松学习JavaScript</a><br/>
· <a target="_blank" href="http://kb.cnblogs.com/page/509431/">如何打好前端游击战</a></span></div>
<span style="font-size: 18px;">» <a target="_blank" href="http://kb.cnblogs.com/">更多知识库文章...</a></span></div>
</div>
</div>
<div><span style="font-size: 18px;"> </span></div>
</div>
<div><span style="font-size: 18px;">Powered by:<br/>
<a style="font-family: Verdana;" href="http://www.cnblogs.com/" name="Hyperlink1">博客园</a></span></div>
<div><span style="font-size: 18px;">Copyright © 如果天空不死</span></div>
</div>
</div>
</div>
</body></html>